#+STARTUP: hideblocks
#+PROPERTY: header-args :libs -I/usr/include/botan-3 -lbotan-3 :flags -std=c++20
* SHA-256
** Plain text input
#+HEADER: :var TEXT = "abcd"
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>
  #include <sstream>
  #include <vector>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      unique_ptr<HashFunction> hash1(HashFunction::create("SHA-256"));

      string plain = TEXT;
      hash1->update(plain);

      cout << "SHA-256: " << hex_encode(hash1->final()) << endl;
      return 0;
  }
#+end_src

#+RESULTS:
: SHA-256: 88D4266FD4E6338D13B845FCF289579D209C897823B9217DA3E161936F031589

** Hex input
#+HEADER: :var INPUT = "01020304"
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>
  #include <sstream>
  #include <string>
  #include <vector>
  //#include <boost/algorithm/hex.hpp>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      unique_ptr<HashFunction> hash1(HashFunction::create("SHA-256"));

      string input = INPUT;
      vector<uint8_t> vec = hex_decode(input);

      hash1->update(vec);

      cout << "SHA-256: " << hex_encode(hash1->final()) << endl;
      return 0;
  }
#+end_src

#+RESULTS:
: SHA-256: 9F64A747E1B97F131FABB6B447296C9B6F0201E79FB3C5356E6C77E89B6A806A

** Plain text repeat
#+HEADER: :var REPEAT_COUNT = 10
#+HEADER: :var TEXT = "abcd"
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>
  #include <sstream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      unique_ptr<HashFunction> hash1(HashFunction::create("SHA-256"));

      string plain = TEXT;

      for(auto i=0; i<REPEAT_COUNT; i++)
          hash1->update(plain);

      cout << "SHA-256: " << hex_encode(hash1->final()) << endl;
      return 0;
  }
#+end_src

#+RESULTS:
: SHA-256: 38986FC4DEFA1CD49321AD652FF3A02A36EBE62E5EE62C0696AC8F86F76DFA36

** Hex repeat
#+HEADER: :var REPEAT_COUNT = 10
#+HEADER: :var INPUT = "01020304"
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>
  #include <sstream>
  #include <string>
  #include <vector>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      unique_ptr<HashFunction> hash1(HashFunction::create("SHA-256"));
      vector<uint8_t> vec = hex_decode(INPUT);

      for(auto i=0; i<REPEAT_COUNT; i++)
          hash1->update(vec);

      cout << "SHA-256: " << hex_encode(hash1->final()) << endl;
      return 0;
  }
#+end_src

#+RESULTS:
: SHA-256: C7C31ED6686BB62C7981C0FFC16759F7E60FB95231C847964D2674A4D269FE72
* MAC
** HMAC-256 hex input
#+HEADER: :var KEY = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var MSG = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <botan/mac.h>
  #include <iostream>
  #include <vector>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> msg = hex_decode(MSG);

      auto hmac = Botan::MessageAuthenticationCode::create_or_throw("HMAC(SHA-256)");

      hmac->set_key(key); hmac->update(msg);

      auto ret = Botan::hex_encode(hmac->final());

      cout << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: B7FB0BE696FEAEC6F647F2F2A7B887944CF39546B1422105FB7FBEBC65787550

** HMAC-512 hex input
#+HEADER: :var KEY = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var MSG = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <botan/mac.h>
  #include <iostream>
  #include <vector>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> msg = hex_decode(MSG);

      auto hmac = Botan::MessageAuthenticationCode::create_or_throw("HMAC(SHA-512)");

      hmac->set_key(key); hmac->update(msg);

      auto ret = Botan::hex_encode(hmac->final());

      cout << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: 8A122F1E030909B37DEF5193AD119F08B9EF0E0BCE48037574EA26F786F4D9C45DA76B7F769B278053A932930372EDDBF10AB21C2A33FADC997250445D6BD71A

** AES-128 CMAC
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var DATA = "000102030405060708090A0B0C0D0E0F"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode("");
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("CMAC(AES-128)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(iv);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // Verify created MAC
      mac->set_key(key);
      mac->start(iv);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| CMAC(AES-128): | 7BCFBBCA7A2EA68B966FC5399F74809E |
| Verification:  | success                          |

#+end_src
** AES-128 GMAC
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var DATA  = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> nonce = hex_decode(NONCE);
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("GMAC(AES-128)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // //Verify created MAC
      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| GMAC(AES-128): | 0474FA92425A16FA4404824A00398C74 |
| Verification:  | success                          |

#+end_src
** AES-192 GMAC
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F0001020304050607"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var DATA  = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> nonce = hex_decode(NONCE);
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("GMAC(AES-192)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // //Verify created MAC
      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| GMAC(AES-192): | FE47D853E827FCA47BB5E87D0F6423B8 |
| Verification:  | success                          |

#+end_src
** AES-256 GMAC
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var DATA  = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> nonce = hex_decode(NONCE);
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("GMAC(AES-256)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // //Verify created MAC
      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| GMAC(AES-256): | 65DC9D99AB0FF0F31351A169DC0EC101 |
| Verification:  | success                          |

#+end_src
** ARIA-128 GMAC
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var DATA  = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> nonce = hex_decode(NONCE);
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("GMAC(ARIA-128)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // //Verify created MAC
      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| GMAC(ARIA-128): | 62B01592621FEACB86CCCC541CC9D169 |
| Verification:   | success                          |

#+end_src
** ARIA-192 GMAC
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F0001020304050607"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var DATA  = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> nonce = hex_decode(NONCE);
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("GMAC(ARIA-192)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // //Verify created MAC
      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| GMAC(ARIA-192): | F0B6264439A0EBDD043ECFDED8A268E8 |
| Verification:   | success                          |

#+end_src
** ARIA-256 GMAC
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var DATA  = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> nonce = hex_decode(NONCE);
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("GMAC(ARIA-256)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // //Verify created MAC
      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| GMAC(ARIA-256): | E0DED6F693CEEFAE2C10DF84EDE5BC15 |
| Verification:   | success                          |

#+end_src
* AES
** AES-128
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> k = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));

      cipher->set_key(k);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128 Encrypt: 69C4E0D86A7B0430D8CDB78070B4C55A

*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "69C4E0D86A7B0430D8CDB78070B4C55A"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " Decrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128 Decrypt: 00112233445566778899AABBCCDDEEFF

** AES-192
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F0001020304050607"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-192"));

      cipher->set_key(key);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-192 Encrypt: 65D50128B115A7780981475A6BD64A0E

*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F0001020304050607"
#+HEADER: :var ENCRYPTED = "65D50128B115A7780981475A6BD64A0E"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-192"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-192 encrypt: 00112233445566778899AABBCCDDEEFF

** AES-256
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-256"));

      cipher->set_key(key);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-256 Encrypt: 8EA2B7CA516745BFEAFC49904B496089
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"
#+HEADER: :var ENCRYPTED = "8EA2B7CA516745BFEAFC49904B496089"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-256"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-256 encrypt: 00112233445566778899AABBCCDDEEFF
** AES-GCM-128
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("AES-128/GCM", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_associated_data(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| AES-128/GCM(16) | Enc: | 565680A8B07A8E5AFE067D91B9168154 |
| AES-128/GCM(16) | Mac: | 343EF77F1C6DE85BB313B51E9AAD2291 |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "565680A8B07A8E5AFE067D91B9168154"
#+HEADER: :var INPUT_TAG = "343EF77F1C6DE85BB313B51E9AAD2291"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("AES-128/GCM", Cipher_Dir::Decryption);

      dec->set_key(key);
      dec->set_associated_data(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
** AES-GCM-192
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF0011223344556677"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/auto_rng.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("AES-192/GCM", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_associated_data(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| AES-192/GCM(16) | Enc: | 545DD08DF08C14CA7100400B4A3833DD |
| AES-192/GCM(16) | Mac: | 94F0FA724CA153D25C5F95A007FC9BD6 |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF0011223344556677"
#+HEADER: :var ENCRYPTED = "545DD08DF08C14CA7100400B4A3833DD"
#+HEADER: :var INPUT_TAG = "94F0FA724CA153D25C5F95A007FC9BD6"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/auto_rng.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("AES-192/GCM", Cipher_Dir::Decryption);

      dec->set_key(key);
      dec->set_associated_data(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: AES-192/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
** AES-GCM-256
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/auto_rng.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("AES-256/GCM", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_associated_data(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| AES-256/GCM(16) | Enc: | D9AB5267E66C88BA53BD3EB1D877E958 |
| AES-256/GCM(16) | Mac: | C7FE61A04359304E950A454644C12C88 |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "D9AB5267E66C88BA53BD3EB1D877E958"
#+HEADER: :var INPUT_TAG = "C7FE61A04359304E950A454644C12C88"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/auto_rng.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("AES-256/GCM", Cipher_Dir::Decryption);

      dec->set_key(key);
      dec->set_associated_data(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: AES-256/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
*** Encrypt text string
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "string text input"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/auto_rng.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const string input(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("AES-256/GCM", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.length());

      enc->set_key(key);
      enc->set_associated_data(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| AES-256/GCM(16) | Enc: | BAFF104ED86BD84EA665FA5161F9692DA4 |
| AES-256/GCM(16) | Mac: | 5E11C2B9BBFBD7D4B4B84BDCF0DDB280   |
*** Decrypt to text string
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "BAFF104ED86BD84EA665FA5161F9692DA4"
#+HEADER: :var INPUT_TAG = "5E11C2B9BBFBD7D4B4B84BDCF0DDB280"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/auto_rng.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("AES-256/GCM", Cipher_Dir::Decryption);

      dec->set_key(key);
      dec->set_associated_data(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      std::string str(pt.begin(), pt.end());
      cout << dec->name() << " Dec: " << str << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: AES-256/GCM(16) Dec: string text input
** AES-CBC-128 NoPadding
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var IV   = "112233445566778899AABBCCDDEEFF00"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("AES-128/CBC/NoPadding", Cipher_Dir::Encryption);
      // cout << " default nonce lengh " << enc->default_nonce_length() << endl;

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/CBC/NoPadding Enc: A28F5667E6CE191444647F5B2E570AE8
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var IV        = "112233445566778899AABBCCDDEEFF00"
#+HEADER: :var ENCRYPTED = "A28F5667E6CE191444647F5B2E570AE8"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("AES-128/CBC/NoPadding", Cipher_Dir::Decryption);

      dec->set_key(key);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/CBC/NoPadding Dec: 102030405060708090A0B0C0D0E0F000
** AES-CBC-128 PKCS7 Padding
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var IV   = "112233445566778899AABBCCDDEEFF00"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("AES-128/CBC/PKCS7", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/CBC/PKCS7 Enc: A28F5667E6CE191444647F5B2E570AE8644F7CE15636077CFB9ADD5CD87FC6C6
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "A28F5667E6CE191444647F5B2E570AE8644F7CE15636077CFB9ADD5CD87FC6C6"
#+HEADER: :var IV        = "112233445566778899AABBCCDDEEFF00"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("AES-128/CBC/PKCS7", Cipher_Dir::Decryption);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/CBC/PKCS7 Dec: 102030405060708090A0B0C0D0E0F000
** AES-CBC-128 OneAndZeros Padding
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var IV   = "112233445566778899AABBCCDDEEFF00"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("AES-128/CBC/OneAndZeros", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/CBC/OneAndZeros Enc: A28F5667E6CE191444647F5B2E570AE8726BB1394D7F883A0A298EE1D9510E64
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "A28F5667E6CE191444647F5B2E570AE8726BB1394D7F883A0A298EE1D9510E64"
#+HEADER: :var IV        = "112233445566778899AABBCCDDEEFF00"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("AES-128/CBC/OneAndZeros", Cipher_Dir::Decryption);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/CBC/OneAndZeros Dec: 102030405060708090A0B0C0D0E0F000
** AES-CBC-256 PKCS7 Padding
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCCDDEEFF00"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("AES-256/CBC/PKCS7", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-256/CBC/PKCS7 Enc: 19F01F6269952794B3714810E26BE3D5E6267DFE058BF54D4E377CBD3E434FD4
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "19F01F6269952794B3714810E26BE3D5E6267DFE058BF54D4E377CBD3E434FD4"
#+HEADER: :var IV        = "112233445566778899AABBCCDDEEFF00"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("AES-256/CBC/PKCS7", Cipher_Dir::Decryption);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: AES-256/CBC/PKCS7 Dec: 102030405060708090A0B0C0D0E0F000
** AES-CBC-256 OneAndZeros Padding
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var TEXT = "112233445566665544332211"
#+HEADER: :var IV   = "112233445566778899AABBCCDDEEFF00"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("AES-256/CBC/OneAndZeros", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-256/CBC/OneAndZeros Enc: 7B1803081258477C997943AE6EDD290C
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "7B1803081258477C997943AE6EDD290C"
#+HEADER: :var IV        = "112233445566778899AABBCCDDEEFF00"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("AES-256/CBC/OneAndZeros", Cipher_Dir::Decryption);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: AES-256/CBC/OneAndZeros Dec: 112233445566665544332211
** AES-CTR-128
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var IV   = "112233445566778899AABBCCDDEEFF00"
#+HEADER: :var TEXT = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("AES-128/CTR", Cipher_Dir::Encryption);
      // cout << " default nonce lengh " << enc->default_nonce_length() << endl;

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: CTR-BE(AES-128) Enc: 0DBFDF84A3810CE19DD7394598DE505F1E0ED42DFBBD7EB164BE5DA7F5CD5C23
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var IV        = "112233445566778899AABBCCDDEEFF00"
#+HEADER: :var ENCRYPTED = "0DBFDF84A3810CE19DD7394598DE505F1E0ED42DFBBD7EB164BE5DA7F5CD5C23"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("AES-128/CTR", Cipher_Dir::Decryption);

      dec->set_key(key);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: CTR-BE(AES-128) Dec: 000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F
** AES-CCM-128
*** Encrypt
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var TEXT  = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var AAD   = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> nonce = hex_decode(NONCE);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("AES-128/CCM", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_associated_data(aad);
      enc->start(nonce);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| AES-128/CCM(16 | 3) Enc: 326AD41E63D474A45618919268C45AF2 |
| AES-128/CCM(16 | 3) Mac: FF60D3CC73E4E6EF95BBB13616C3AE27 |
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "326AD41E63D474A45618919268C45AF2"
#+HEADER: :var INPUT_TAG = "FF60D3CC73E4E6EF95BBB13616C3AE27"
#+HEADER: :var NONCE     = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> nonce = hex_decode(NONCE);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("AES-128/CCM", Cipher_Dir::Decryption);

      dec->set_key(key);
      dec->set_associated_data(aad);
      dec->start(nonce);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
| AES-128/CCM(16 | 3) Dec: 102030405060708090A0B0C0D0E0F000 |
* AES key wrapper (RFC3394)
** Using botan interface
*** Demo
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var KEY = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <botan/nist_keywrap.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> key = hex_decode(KEY);

      uint8_t keyArr[key.size()];
      for(int i=0; i<key.size(); i++)
          keyArr[i] = key[i];

      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));
      cipher->set_key(kek);

      vector<uint8_t> wrappedKey = nist_key_wrap(keyArr, key.size(), *cipher);
      cout << "WrappedKey: " << hex_encode(wrappedKey) << endl;

      uint8_t wrappedKeyArr[wrappedKey.size()];
      for(int i=0; i<wrappedKey.size(); i++)
          wrappedKeyArr[i] = wrappedKey[i];

      secure_vector<uint8_t> restoredKey = nist_key_unwrap(wrappedKeyArr, wrappedKey.size(), *cipher);
      cout << "UnWrappedKey: " << hex_encode(restoredKey) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| WrappedKey:   | 1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5 |
| UnWrappedKey: | 00112233445566778899AABBCCDDEEFF                 |
*** Wrap
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var KEY = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <botan/nist_keywrap.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> key = hex_decode(KEY);

      uint8_t keyArr[key.size()];
      for(int i=0; i<key.size(); i++)
          keyArr[i] = key[i];

      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));
      cipher->set_key(kek);

      vector<uint8_t> wrappedKey = nist_key_wrap(keyArr, key.size(), *cipher);
      cout << "WrappedKey: " << hex_encode(wrappedKey) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: WrappedKey: 1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5
*** Unwrap
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var WRAPPED_KEY = "1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <botan/nist_keywrap.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> wrappedKey = hex_decode(WRAPPED_KEY);;

      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));
      cipher->set_key(kek);

      uint8_t wrappedKeyArr[wrappedKey.size()];
      for(int i=0; i<wrappedKey.size(); i++)
          wrappedKeyArr[i] = wrappedKey[i];

      secure_vector<uint8_t> restoredKey = nist_key_unwrap(wrappedKeyArr, wrappedKey.size(), *cipher);
      cout << "UnWrappedKey: " << hex_encode(restoredKey) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: UnWrappedKey: 00112233445566778899AABBCCDDEEFF
** Using implemented function
*** Wrapper functions
#+name: wrapper_functions
#+begin_src C++
  static vector<uint8_t> defaultIv{0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6};

  int keyWrapperWithIv(vector<uint8_t> &kek, vector<uint8_t> &key, vector<uint8_t> &wrappedKey, vector<uint8_t> &iv)
  {
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));
      cipher->set_key(kek);

      int n = key.size() / 8;
      uint8_t R[n+1][8] = {0,};
      vector<uint8_t> A = iv;

      for(int i=0; i<n; i++)
          std::copy(key.begin()+(i*8), key.begin()+(i*8)+8, R[i+1]);

      for(int j=0; j<=5; j++) {
          for(int i=1; i<=n; i++) {
              vector<uint8_t> B(A);
              B.insert(B.end(), R[i], R[i]+8);

              cipher->encrypt(B);

              A.clear();
              A.assign(B.begin(), B.begin()+8);

              int toXor = (n*j)+i, Ai = 7;
              while(toXor != 0) {
                  A[Ai] ^= (toXor & 0xFF);
                  Ai -= 1;
                  toXor >>= 8;
              }

              std::copy(B.begin()+8, B.end(), R[i]);
          }
      }

      wrappedKey.clear();
      wrappedKey.assign(A.begin(), A.end());

      for(int i=1; i<=n; i++)
          wrappedKey.insert(wrappedKey.end(), R[i], R[i]+8);

      cout << "Wrappedkey: " << hex_encode(wrappedKey) << endl;

      return 0;
  }

  int keyUnwrapperWithiv(vector<uint8_t> &kek, vector<uint8_t> &wrappedKey, vector<uint8_t> &key, vector<uint8_t> iv)
  {
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));
      cipher->set_key(kek);

      int n = wrappedKey.size() / 8 - 1;
      uint8_t R[n+2][8] = {0,};
      vector<uint8_t> A;
      A.assign(wrappedKey.begin(), wrappedKey.begin()+8);

      for(int i=1; i<n+1; i++)
          std::copy(wrappedKey.begin()+(i*8), wrappedKey.begin()+(i*8)+8, R[i]);

      for(int j=5; j>=0; j--) {
          for(int i=n; i>=1; i--) {
              int toXor = (n*j)+i, Ai = 7;
              while(toXor != 0) {
                  A[Ai] ^= (toXor & 0xFF);
                  Ai -= 1;
                  toXor >>= 8;
              }

              vector<uint8_t> B(A);
              B.insert(B.end(), R[i], R[i]+8);

              cipher->decrypt(B);

              A.clear();
              A.assign(B.begin(), B.begin()+8);

              std::copy(B.begin()+8, B.end(), R[i]);
          }
      }

      key.clear();
      key.insert(key.end(), R[1], R[1]+16);

      if(A != iv) {
          cout << "IV mismatch" << endl;
          return -1;
      }

      cout << "IV: " << hex_encode(A) << endl;
      cout << "OriginalKey: " << hex_encode(key) << endl;

      return 0;
  }


  int keyWrapper(vector<uint8_t> &kek, vector<uint8_t> &key, vector<uint8_t> &wrappedKey, vector<uint8_t> &iv)
  {
      keyWrapperWithIv(kek, key, wrappedKey, iv);
      return 0;
  }
  int keyWrapper(vector<uint8_t> &kek, vector<uint8_t> &key, vector<uint8_t> &wrappedKey)
  {
      keyWrapperWithIv(kek, key, wrappedKey, defaultIv);
      return 0;
  }

  int keyUnwrapper(vector<uint8_t> &kek, vector<uint8_t> &wrappedKey, vector<uint8_t> &key, vector<uint8_t> iv)
  {
      keyUnwrapperWithiv(kek, wrappedKey, key, iv);
      return 0;
  }
  int keyUnwrapper(vector<uint8_t> &kek, vector<uint8_t> &wrappedKey, vector<uint8_t> &key)
  {
      keyUnwrapperWithiv(kek, wrappedKey, key, defaultIv);
      return 0;
  }
#+end_src

+RESULTS: wrapper_functions

*** Demo
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var KEY = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  <<wrapper_functions>>

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> wrappedKey;
      vector<uint8_t> restoredKey;

      keyWrapper(kek, key, wrappedKey);
      keyUnwrapper(kek, wrappedKey, restoredKey);

      return 0;
  }
#+end_src

#+RESULTS:
| Wrappedkey:  | 1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5 |
| IV:          | A6A6A6A6A6A6A6A6                                 |
| OriginalKey: | 00112233445566778899AABBCCDDEEFF                 |

*** Wrap
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var KEY = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  <<wrapper_functions>>

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> wrappedKey;

      keyWrapper(kek, key, wrappedKey);

      return 0;
  }
#+end_src

#+RESULTS:
: Wrappedkey: 1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5

*** Unwrap
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var WRAPPED_KEY = "1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  <<wrapper_functions>>

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> wrappedKey = hex_decode(WRAPPED_KEY);;
      vector<uint8_t> restoredKey;

      keyUnwrapper(kek, wrappedKey, restoredKey);

      return 0;
  }
#+end_src

#+RESULTS:
| IV:          | A6A6A6A6A6A6A6A6                 |
| OriginalKey: | 00112233445566778899AABBCCDDEEFF |

*** Wrap with IV
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var KEY = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var IV = "A6A6A6A6A6A6A6A6"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  <<wrapper_functions>>

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> iv = hex_decode(IV);
      vector<uint8_t> wrappedKey;

      keyWrapper(kek, key, wrappedKey, iv);

      return 0;
  }
#+end_src

#+RESULTS:
: Wrappedkey: 1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5

*** Unwrap with IV
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var WRAPPED_KEY = "1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5"
#+HEADER: :var IV = "A6A6A6A6A6A6A6A6"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  <<wrapper_functions>>

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> wrappedKey = hex_decode(WRAPPED_KEY);;
      vector<uint8_t> iv = hex_decode(IV);
      vector<uint8_t> restoredKey;

      keyUnwrapper(kek, wrappedKey, restoredKey, iv);

      return 0;
  }
#+end_src

#+RESULTS:
| IV:          | A6A6A6A6A6A6A6A6                 |
| OriginalKey: | 00112233445566778899AABBCCDDEEFF |
* ARIA
** ARIA-128
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> k = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-128"));

      cipher->set_key(k);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128 Encrypt: D718FBD6AB644C739DA95F3BE6451778

*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "D718FBD6AB644C739DA95F3BE6451778"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-128"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " Decrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128 Decrypt: 00112233445566778899AABBCCDDEEFF

** ARIA-192
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F0001020304050607"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-192"));

      cipher->set_key(key);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-192 Encrypt: 0DEDEC2A613869147C86397A97CA44F6

*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F0001020304050607"
#+HEADER: :var ENCRYPTED = "0DEDEC2A613869147C86397A97CA44F6"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-192"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-192 encrypt: 00112233445566778899AABBCCDDEEFF

** ARIA-256
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-256"));

      cipher->set_key(key);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-256 Encrypt: F92BD7C79FB72E2F2B8F80C1972D24FC
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"
#+HEADER: :var ENCRYPTED = "F92BD7C79FB72E2F2B8F80C1972D24FC"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-256"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-256 encrypt: 00112233445566778899AABBCCDDEEFF
** ARIA-GCM-128
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("ARIA-128/GCM", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_associated_data(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| ARIA-128/GCM(16) | Enc: | B2949DD080ADFFA66C72BE18A3817CF3 |
| ARIA-128/GCM(16) | Mac: | B7DFC8E22C8C3212AD7ACED059966E7A |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "B2949DD080ADFFA66C72BE18A3817CF3"
#+HEADER: :var INPUT_TAG = "B7DFC8E22C8C3212AD7ACED059966E7A"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("ARIA-128/GCM", Cipher_Dir::Decryption);

      dec->set_key(key);
      dec->set_associated_data(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
** ARIA-GCM-192
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF0011223344556677"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("ARIA-192/GCM", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_associated_data(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| ARIA-192/GCM(16) | Enc: | E203BFFE67525F15E258F465418F9378 |
| ARIA-192/GCM(16) | Mac: | 7AEBC287AE39724DB396BE4105808CD4 |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF0011223344556677"
#+HEADER: :var ENCRYPTED = "E203BFFE67525F15E258F465418F9378"
#+HEADER: :var INPUT_TAG = "7AEBC287AE39724DB396BE4105808CD4"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("ARIA-192/GCM", Cipher_Dir::Decryption);

      dec->set_key(key);
      dec->set_associated_data(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-192/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
** ARIA-GCM-256
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("ARIA-256/GCM", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_associated_data(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| ARIA-256/GCM(16) | Enc: | 5FD6F4743CC128D4692E467AC7082F48 |
| ARIA-256/GCM(16) | Mac: | 4A85EA53925DA74964CE1BE7F38A3840 |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "5FD6F4743CC128D4692E467AC7082F48"
#+HEADER: :var INPUT_TAG = "4A85EA53925DA74964CE1BE7F38A3840"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("ARIA-256/GCM", Cipher_Dir::Decryption);

      dec->set_key(key);
      dec->set_associated_data(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-256/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
*** Encrypt text string
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "string text input"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const string input(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("ARIA-256/GCM", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.length());

      enc->set_key(key);
      enc->set_associated_data(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| ARIA-256/GCM(16) | Enc: | 3C82B65D02C678209CF6829A7E86AF3D17 |
| ARIA-256/GCM(16) | Mac: | A75370B9E717F73875F02E4491FB022D   |
*** Decrypt to text string
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "3C82B65D02C678209CF6829A7E86AF3D17"
#+HEADER: :var INPUT_TAG = "A75370B9E717F73875F02E4491FB022D"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/aead.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("ARIA-256/GCM", Cipher_Dir::Decryption);

      dec->set_key(key);
      dec->set_associated_data(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      std::string str(pt.begin(), pt.end());
      cout << dec->name() << " Dec: " << str << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-256/GCM(16) Dec: string text input
** ARIA-CBC-128
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("ARIA-128/CBC/NoPadding", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128/CBC/NoPadding Enc: 57AC63C3A8F0121A4D54B0A8021EEBC9
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "57AC63C3A8F0121A4D54B0A8021EEBC9"
#+HEADER: :var IV        = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("ARIA-128/CBC/NoPadding", Cipher_Dir::Decryption);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128/CBC/NoPadding Dec: 102030405060708090A0B0C0D0E0F000
** ARIA-CBC-128 PKCS7 Padding
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("ARIA-128/CBC/PKCS7", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128/CBC/PKCS7 Enc: 57AC63C3A8F0121A4D54B0A8021EEBC9A1E16B15F52E223EBCBCB515A68E1342
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "57AC63C3A8F0121A4D54B0A8021EEBC9A1E16B15F52E223EBCBCB515A68E1342"
#+HEADER: :var IV        = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("ARIA-128/CBC/PKCS7", Cipher_Dir::Decryption);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128/CBC/PKCS7 Dec: 102030405060708090A0B0C0D0E0F000
** ARIA-CTR-128
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("ARIA-128/CTR", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: CTR-BE(ARIA-128) Enc: 787C57CE043D0BB74EAC829782E5563C
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "787C57CE043D0BB74EAC829782E5563C"
#+HEADER: :var IV        = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("ARIA-128/CTR", Cipher_Dir::Decryption);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: CTR-BE(ARIA-128) Dec: 102030405060708090A0B0C0D0E0F000
* DES
** DES
*** Encrypt
#+HEADER: :var KEY  = "0001020304050607"
#+HEADER: :var TEXT = "0011223344556677"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> k = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("DES"));

      cipher->set_key(k);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: DES Encrypt: 3EF0A891CF8ED990

*** Decrypt
#+HEADER: :var KEY       = "0001020304050607"
#+HEADER: :var ENCRYPTED = "3EF0A891CF8ED990"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("DES"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " Decrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: DES Decrypt: 0011223344556677

** DES-CBC
*** Encrypt
#+HEADER: :var KEY  = "0001020304050607"
#+HEADER: :var TEXT = "0011223344556677"
#+HEADER: :var IV   = "FFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);


      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("DES/CBC/NoPadding", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: DES/CBC/NoPadding Enc: 1D906CB69C75537A
*** Decrypt
#+HEADER: :var KEY       = "0001020304050607"
#+HEADER: :var ENCRYPTED = "1D906CB69C75537A"
#+HEADER: :var IV        = "FFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("DES/CBC/NoPadding", Cipher_Dir::Decryption);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: DES/CBC/NoPadding Dec: 0011223344556677
** DES-CBC PKCS7 Padding
*** Encrypt
#+HEADER: :var KEY  = "0001020304050607"
#+HEADER: :var TEXT = "0011223344556677"
#+HEADER: :var IV   = "FFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);


      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("DES/CBC/PKCS7", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: DES/CBC/PKCS7 Enc: 1D906CB69C75537AE0A782AC616A9763
*** Decrypt
#+HEADER: :var KEY       = "0001020304050607"
#+HEADER: :var ENCRYPTED = "1D906CB69C75537AE0A782AC616A9763"
#+HEADER: :var IV        = "FFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("DES/CBC/PKCS7", Cipher_Dir::Decryption);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: DES/CBC/PKCS7 Dec: 0011223344556677
** DES-CTR
*** Encrypt
#+HEADER: :var KEY  = "0001020304050607"
#+HEADER: :var TEXT = "0011223344556677"
#+HEADER: :var IV   = "FFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("DES/CTR", Cipher_Dir::Encryption);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: CTR-BE(DES) Enc: 6B77DC07D92B9B3F
*** Decrypt
#+HEADER: :var KEY       = "0001020304050607"
#+HEADER: :var ENCRYPTED = "6B77DC07D92B9B3F"
#+HEADER: :var IV        = "FFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("DES/CTR", Cipher_Dir::Decryption);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: CTR-BE(DES) Dec: 0011223344556677
* ECDH
** Random key - Create sessionkey
#+HEADER: :var TEXT        = "test msg"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdh.h>
  #include <botan/ec_group.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      AutoSeeded_RNG rng;
      // ec domain and
      EC_Group domain("secp256r1");
      // generate ECDH keys
      ECDH_PrivateKey keyA(rng, domain);
      ECDH_PrivateKey keyB(rng, domain);
      // Construct key agreements
      // string kdf = "KDF2(SHA-256)";
      // PK_Key_Agreement ecdhA(keyA,rng,kdf);
      // PK_Key_Agreement ecdhB(keyB,rng,kdf);
      PK_Key_Agreement ecdhA(keyA,rng,"Raw");
      PK_Key_Agreement ecdhB(keyB,rng,"Raw");

      BigInt bigA = keyA.private_value();
      cout << "private_keyA: " << bigA.to_hex_string() << endl;
      vector<uint8_t> pubkA = keyA.public_key_bits();
      cout << "public_keyA: " << hex_encode(pubkA) << endl;

      BigInt bigB = keyB.private_value();
      cout << "private_keyB: " << bigB.to_hex_string() << endl;
      vector<uint8_t> pubkB = keyB.public_key_bits();
      cout << "public_keyB: " << hex_encode(pubkB) << endl;


      // Agree on shared secret and derive symmetric key of 256 bit length
      secure_vector<uint8_t> sA = ecdhA.derive_key(32,keyB.public_value()).bits_of();
      secure_vector<uint8_t> sB = ecdhB.derive_key(32,keyA.public_value()).bits_of();

      if(sA != sB)
          return 1;

      cout << "agreed_key: " << hex_encode(sA) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_keyA: | 0xACA21AE8FD3A288CAA893322B8E2221BE1DFF721354330C260DD2707190FE7AB                                                                 |
| public_keyA:  | 045A40FAC77D2D58DA2CFB35C4CA0D2428819768598AD8429B310CC0508AEB2F8517770B9AFDB058DF222AA00FDC6A0AFE083A916F00B12C38DE0435BA7E1FC0A7 |
| private_keyB: | 0xC9183A2AD2641A1836792126CCA0E538D5BF04ABFAB818B2865E2E4343FBFD62                                                                 |
| public_keyB:  | 04CE15F7B90CB38C6ADDD9881C8525D32BA7ED0CEF247E13F8CFFA14820166EF48A72C1C0FD9524D64F07F3CD7D62DDE79A89AE36EE735D67D4548EA4650C14122 |
| agreed_key:   | D490E43A975B4EFF8F031D648A5ADC98AC3D568997022F313BE1BE3A9641936D                                                                   |

** Existing key(Hex) - Create sessionkey (Public key can be omitted)
#+HEADER: :var A_PRIVATE_KEY = "272381629D174EAD2F3939F2FFDCFCFDAFB5885E789EBA30969127F6B6E8F8E2"
#+HEADER: :var A_PUBLIC_KEY  = "048D05F3D3FC92A06F97B3D6861D0C9425483E16E2F6AA2729F99211FF1B364E10A46B47A96EF995785245FC5302EF45A0D5EF1486B9865603969118D455AFBB53"
#+HEADER: :var B_PRIVATE_KEY = "EBF6E5A05A4AC0D1D2B2A629BF808B50B51DB7ED5E7CBAE968783C925FCC679D"
#+HEADER: :var B_PUBLIC_KEY  = "04EFB6C4A48C69D85C6831922530536FE4500D16F90A454960465CDBF178E4728373D41625F3906A69107463FDD0FA03A1C4E1EB619968DEFEB41D1338B65049D4"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdh.h>
  #include <botan/ec_group.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      AutoSeeded_RNG rng;

      const vector<uint8_t> aPriKey = hex_decode(A_PRIVATE_KEY);
      const vector<uint8_t> bPriKey = hex_decode(B_PRIVATE_KEY);

      BigInt aPkey(aPriKey);
      BigInt bPkey(bPriKey);

      // ec domain and
      EC_Group domain("secp256r1");
      // generate ECDH keys
      ECDH_PrivateKey keyA(rng, domain, aPkey);
      ECDH_PrivateKey keyB(rng, domain, bPkey);

      ECDH_PublicKey keyApub(keyA);
      ECDH_PublicKey keyBpub(keyB);

      vector<uint8_t> pkA = keyApub.public_key_bits();
      if (A_PUBLIC_KEY != "" && hex_encode(pkA) != A_PUBLIC_KEY) {
          cout << "A : Invalid key pair." << endl;
          return 0;
      }

      vector<uint8_t> pkB = keyBpub.public_key_bits();
      if (B_PUBLIC_KEY != "" && hex_encode(pkB) != B_PUBLIC_KEY) {
          cout << "B : Invalid key pair." << endl;
          return 0;
      }

      // Construct key agreements
      // string kdf = "KDF2(SHA-256)";
      // PK_Key_Agreement ecdhA(keyA,rng,kdf);
      // PK_Key_Agreement ecdhB(keyB,rng,kdf);
      PK_Key_Agreement ecdhA(keyA,rng,"Raw");
      PK_Key_Agreement ecdhB(keyB,rng,"Raw");

      BigInt bigA = keyA.private_value();
      cout << "private_keyA: " << bigA.to_hex_string() << endl;
      vector<uint8_t> pubkA = keyA.public_key_bits();
      cout << "public_keyA: " << hex_encode(pubkA) << endl;

      BigInt bigB = keyB.private_value();
      cout << "private_keyB: " << bigB.to_hex_string() << endl;
      vector<uint8_t> pubkB = keyB.public_key_bits();
      cout << "public_keyB: " << hex_encode(pubkB) << endl;


      // Agree on shared secret and derive symmetric key of 256 bit length
      secure_vector<uint8_t> sA = ecdhA.derive_key(32,keyB.public_value()).bits_of();
      secure_vector<uint8_t> sB = ecdhB.derive_key(32,keyA.public_value()).bits_of();

      if(sA != sB)
          return 1;

      cout << "agreed_key: " << hex_encode(sA) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_keyA: | 0x272381629D174EAD2F3939F2FFDCFCFDAFB5885E789EBA30969127F6B6E8F8E2                                                                 |
| public_keyA:  | 048D05F3D3FC92A06F97B3D6861D0C9425483E16E2F6AA2729F99211FF1B364E10A46B47A96EF995785245FC5302EF45A0D5EF1486B9865603969118D455AFBB53 |
| private_keyB: | 0xEBF6E5A05A4AC0D1D2B2A629BF808B50B51DB7ED5E7CBAE968783C925FCC679D                                                                 |
| public_keyB:  | 04EFB6C4A48C69D85C6831922530536FE4500D16F90A454960465CDBF178E4728373D41625F3906A69107463FDD0FA03A1C4E1EB619968DEFEB41D1338B65049D4 |
| agreed_key:   | 3C027AF77D256133E465CE56ABC1CF31B3D428FD5FE528A4481BCF5D295DAA69                                                                   |

** Existing key(Big Int) - Create sessionkey
#+HEADER: :var A_PRIVATE_KEY = "17702933725911759833018382133741290876335542967772335450363342488878254192866"
#+HEADER: :var A_PUBLIC_KEY  = "61017218725251769835925365666700278871445386965526678184487919969123210546842177730340048341794298839866705223449066751284256420111064842794150013009115987"
#+HEADER: :var B_PRIVATE_KEY = "106729748618016823529684004271423234939788438170848142794308826289302701631389"
#+HEADER: :var B_PUBLIC_KEY  = "66186069373064324507716733592744495348638623787425372736469519431587026981344737339468148830286137966427921162803027707669848205986009555327089307961805268"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdh.h>
  #include <botan/ec_group.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      AutoSeeded_RNG rng;

      BigInt aPkey(A_PRIVATE_KEY);
      BigInt bPkey(B_PRIVATE_KEY);

      // ec domain and
      EC_Group domain("secp256r1");
      // generate ECDH keys
      ECDH_PrivateKey keyA(rng, domain, aPkey);
      ECDH_PrivateKey keyB(rng, domain, bPkey);

      ECDH_PublicKey keyApub(keyA);
      ECDH_PublicKey keyBpub(keyB);

      vector<uint8_t> pkA = keyApub.public_key_bits();
      string strPkA(A_PUBLIC_KEY);
      if (A_PUBLIC_KEY != "" && BigInt(pkA) != BigInt(strPkA)) {
          cout << "A : Invalid key pair." << endl;
          return 0;
      }

      vector<uint8_t> pkB = keyBpub.public_key_bits();
      string strPkB(B_PUBLIC_KEY);
      if (B_PUBLIC_KEY != "" && BigInt(pkB) != BigInt(strPkB)) {
          cout << "B : Invalid key pair." << endl;
          return 0;
      }

      // Construct key agreements
      // string kdf = "KDF2(SHA-256)";
      // PK_Key_Agreement ecdhA(keyA,rng,kdf);
      // PK_Key_Agreement ecdhB(keyB,rng,kdf);
      PK_Key_Agreement ecdhA(keyA,rng,"Raw");
      PK_Key_Agreement ecdhB(keyB,rng,"Raw");

      BigInt bigA = keyA.private_value();
      cout << "private_keyA: " << bigA.to_hex_string() << endl;
      vector<uint8_t> pubkA = keyA.public_key_bits();
      cout << "public_keyA: " << hex_encode(pubkA) << endl;

      BigInt bigB = keyB.private_value();
      cout << "private_keyB: " << bigB.to_hex_string() << endl;
      vector<uint8_t> pubkB = keyB.public_key_bits();
      cout << "public_keyB: " << hex_encode(pubkB) << endl;


      // Agree on shared secret and derive symmetric key of 256 bit length
      secure_vector<uint8_t> sA = ecdhA.derive_key(32,keyB.public_value()).bits_of();
      secure_vector<uint8_t> sB = ecdhB.derive_key(32,keyA.public_value()).bits_of();

      if(sA != sB)
          return 1;

      cout << "agreed_key(Hex): " << hex_encode(sA) << endl;
      cout << "agreed_key(BigInt): " << BigInt(sA).to_dec_string() << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_keyA:       |                                                                 0x272381629D174EAD2F3939F2FFDCFCFDAFB5885E789EBA30969127F6B6E8F8E2 |
| public_keyA:        | 048D05F3D3FC92A06F97B3D6861D0C9425483E16E2F6AA2729F99211FF1B364E10A46B47A96EF995785245FC5302EF45A0D5EF1486B9865603969118D455AFBB53 |
| private_keyB:       |                                                                 0xEBF6E5A05A4AC0D1D2B2A629BF808B50B51DB7ED5E7CBAE968783C925FCC679D |
| public_keyB:        | 04EFB6C4A48C69D85C6831922530536FE4500D16F90A454960465CDBF178E4728373D41625F3906A69107463FDD0FA03A1C4E1EB619968DEFEB41D1338B65049D4 |
| agreed_key(Hex):    |                                                                   3C027AF77D256133E465CE56ABC1CF31B3D428FD5FE528A4481BCF5D295DAA69 |
| agreed_key(BigInt): |                                                      27143153294466088880496358460888297068895292863519913920482132860624216894057 |

** Existing key(Hex) - Create sessionkey with PriKey A, PubKey B
#+HEADER: :var A_PRIVATE_KEY = "272381629D174EAD2F3939F2FFDCFCFDAFB5885E789EBA30969127F6B6E8F8E2"
#+HEADER: :var B_PUBLIC_KEY  = "EFB6C4A48C69D85C6831922530536FE4500D16F90A454960465CDBF178E4728373D41625F3906A69107463FDD0FA03A1C4E1EB619968DEFEB41D1338B65049D4"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdh.h>
  #include <botan/ec_group.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      AutoSeeded_RNG rng;

      const vector<uint8_t> aPriKey = hex_decode(A_PRIVATE_KEY);
      vector<uint8_t> bPubKey = hex_decode(B_PUBLIC_KEY);
      bPubKey.insert(bPubKey.begin(), 4);

      BigInt aPkey(aPriKey);

      // ec domain and
      EC_Group domain("secp256r1");
      // generate ECDH keys
      ECDH_PrivateKey keyA(rng, domain, aPkey);

      ECDH_PublicKey keyApub(keyA);

      // Construct key agreements
      // string kdf = "KDF2(SHA-256)";
      // PK_Key_Agreement ecdhA(keyA,rng,kdf);
      // PK_Key_Agreement ecdhB(keyB,rng,kdf);
      PK_Key_Agreement ecdhA(keyA,rng,"Raw");

      BigInt bigA = keyA.private_value();
      cout << "private_keyA: " << bigA.to_hex_string() << endl;
      vector<uint8_t> pubkA = keyA.public_key_bits();
      cout << "public_keyA: " << hex_encode(pubkA) << endl;

      // Agree on shared secret and derive symmetric key of 256 bit length
      secure_vector<uint8_t> sA = ecdhA.derive_key(32,bPubKey).bits_of();

      cout << "agreed_key: " << hex_encode(sA) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_keyA: | 0x272381629D174EAD2F3939F2FFDCFCFDAFB5885E789EBA30969127F6B6E8F8E2                                                                 |
| public_keyA:  | 048D05F3D3FC92A06F97B3D6861D0C9425483E16E2F6AA2729F99211FF1B364E10A46B47A96EF995785245FC5302EF45A0D5EF1486B9865603969118D455AFBB53 |
| agreed_key:   | 3C027AF77D256133E465CE56ABC1CF31B3D428FD5FE528A4481BCF5D295DAA69                                                                   |

* ECDSA
** Demo
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/ec_group.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      std::string text("testmsg");
      std::vector<uint8_t> data(text.data(),text.data()+text.length());

      Botan::AutoSeeded_RNG rng;

      // Generate ECDSA keypair
      Botan::ECDSA_PrivateKey prikey(rng, Botan::EC_Group("secp256r1"));
      Botan::ECDSA_PublicKey pubkey(prikey);

      BigInt bgprikey = prikey.private_value();
      cout << "prikey: " << bgprikey.to_hex_string() << endl;

      // Public key generated from private key
      vector<uint8_t> pubk = pubkey.public_key_bits();
      cout << "pubkey1: " << hex_encode(pubk) << endl;

      // Pubic key value from private key
      vector<uint8_t> pubk2 = prikey.public_key_bits() ;
      cout << "pubkey2: " << hex_encode(pubk2) << endl;

      // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;

      // verify signature
      Botan::PK_Verifier verifier(pubkey, "EMSA1(SHA-256)");
      verifier.update(data);
      std::cout << "signature " << (verifier.check_signature(signature)? "valid" : "invalid");

      return 0;
  }
#+end_src

#+RESULTS:
| prikey:    | 0xC071BB13BB66C0E580CA4BFDC5D2D190CB1A35CD866FA83EA3C0E4CD3B36CD78                                                                 |
| pubkey1:   | 0412FB82F4E35B6DF039AC98C6279DC5989634D42E78F6AE18B7154FF453EAFEEAAF7221DE49909ADFF97D4861C8E054085E4E38F87A9E6C40064148314E1477B4 |
| pubkey2:   | 0412FB82F4E35B6DF039AC98C6279DC5989634D42E78F6AE18B7154FF453EAFEEAAF7221DE49909ADFF97D4861C8E054085E4E38F87A9E6C40064148314E1477B4 |
| Signature: | 02C02C80C107FD0D819EE491D0954DE0B1DDD675E9C4E3DB0645AE287BA720F94DB8B899AFD04C6C408F756C5D4E40A9587CBDEB73EE811B42C35C9267E7D071   |
| signature  | valid                                                                                                                              |

** Random key - Create signature - TEXT input
#+HEADER: :var TEXT        = "test msg"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      Botan::AutoSeeded_RNG rng;

      // Generate ECDSA keypair
      Botan::ECDSA_PrivateKey prikey(rng, Botan::EC_Group("secp256r1"));
      Botan::ECDSA_PublicKey pubkey(prikey);

      BigInt bgprikey = prikey.private_value();
      cout << "private_key: " << bgprikey.to_hex_string() << endl;

      // Public key generated from private key
      vector<uint8_t> pubk = pubkey.public_key_bits();
      cout << "public_key: " << hex_encode(pubk) << endl;

      std::string text(TEXT);
      std::vector<uint8_t> data(text.data(),text.data()+text.length());

      // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_key: | 0xC2B11482D38E016008AD263D2DAE7F1668BFFD67ACDEC0AFC7D6130661E23CF6                                                                 |
| public_key:  | 04D6C3E70D5D2BBE2839BD9D96542654F6324B0891588DB7B70C83CE48B2E23A089B9CEE5F1EF0ED18377D89363306772BF264FC0485134F376E88F115798E072E |
| Signature:   | F88B35DED195278ADD3320AABA51E16DD98FD0882F34445CD8C44582EABCBF7E7ABACD583487F0E06CFAC099B04CA0B5FB9FE192A45EAD4EB63368125622E1AD   |

** Random key - Create signature - HEX input
#+HEADER: :var TEXT        = "010203040506"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      Botan::AutoSeeded_RNG rng;

      // Generate ECDSA keypair
      Botan::ECDSA_PrivateKey prikey(rng, Botan::EC_Group("secp256r1"));
      Botan::ECDSA_PublicKey pubkey(prikey);
      std::vector<uint8_t> data = hex_decode(TEXT);

      BigInt bgprikey = prikey.private_value();
      cout << "private_key: " << bgprikey.to_hex_string() << endl;

      // Public key generated from private key
      vector<uint8_t> pubk = pubkey.public_key_bits();
      cout << "public_key: " << hex_encode(pubk) << endl;


      // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_key: | 0x6266287DDD8AB54C0E034B19A66E69A3E8939901C1E671E6FF3C658942F2478A                                                                 |
| public_key:  | 04F87F7C48974225E1C6BC49EB924B9652675FD0B362CB6F0B94CAE0846DA6E57DFE0D9C3AC1F4E32BDDECC50163FE4481E4D244B918365DCC1E88B3EF95A604DD |
| Signature:   | 09463A3AC192096F0769B1F5EC42B0E56155D36AD77FC9BF5FB8649522D4BAA3C4CAA5C3C67FE4874034F501F5A87C1A0B68E57413045BEE8970B7FE90CD95EB   |

** Existing key - Create signature TEXT input
#+HEADER: :var TEXT        = "test msg"
#+HEADER: :var PRIVATE_KEY = "DBC868EF66949314FC040180FC6F1A9867466028364140361FF770733B23EF76"
#+HEADER: :var PUBLIC_KEY  = "04A9A712C7B56F3C878F230C6F6F31564D11D29F9E30A146E7F99904F6FD743708662C3B989201E6437F9DC261AF500F68C93EF2382F93F9B842E679F5297C1907"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      Botan::AutoSeeded_RNG rng;
  
      const vector<uint8_t> private_key = hex_decode(PRIVATE_KEY);
      const vector<uint8_t> public_key = hex_decode(PUBLIC_KEY);
  
      BigInt bprikey(private_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bprikey);
      ECDSA_PublicKey pubkey(prikey);
  
      vector<uint8_t> pubk = pubkey.public_key_bits() ;
      if (hex_encode(pubk) != PUBLIC_KEY) {
          cout << "Invalid key pair." << endl;
          return 0;
      }
  
      std::string text(TEXT);
      std::vector<uint8_t> data(text.data(),text.data()+text.length());
  
      // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature: BE5F8ACA879F2AA8D2385134AAD44792EAF84CE997A8C4328608BE75447999DB7934DB668DFE49DD4E5CCF7F13CDB304D148B510A4FBA6F3D8B00DAD97FB806E

** Existing key - Create signature HEX input
#+HEADER: :var TEXT        = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var PRIVATE_KEY = "DBC868EF66949314FC040180FC6F1A9867466028364140361FF770733B23EF76"
#+HEADER: :var PUBLIC_KEY  = "04A9A712C7B56F3C878F230C6F6F31564D11D29F9E30A146E7F99904F6FD743708662C3B989201E6437F9DC261AF500F68C93EF2382F93F9B842E679F5297C1907"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      Botan::AutoSeeded_RNG rng;
  
      const vector<uint8_t> private_key = hex_decode(PRIVATE_KEY);
      const vector<uint8_t> public_key = hex_decode(PUBLIC_KEY);
      std::vector<uint8_t> data = hex_decode(TEXT);
  
      BigInt bprikey(private_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bprikey);
      ECDSA_PublicKey pubkey(prikey);
  
      vector<uint8_t> pubk = pubkey.public_key_bits() ;
      if (hex_encode(pubk) != PUBLIC_KEY) {
          cout << "Invalid key pair." << endl;
          return 0;
      }
  
      // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature: 77A75FD1894F4113B5904CE6FBB8819B658856266FFCE3417C799C8E9163D87865CC4D12F3504181C53BAE8C1D497764E47080B73C72764D5F6E717C48E08896

** Existing key - Create signature HEX input with only private key
#+HEADER: :var TEXT        = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var PRIVATE_KEY = "DBC868EF66949314FC040180FC6F1A9867466028364140361FF770733B23EF76"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      Botan::AutoSeeded_RNG rng;
  
      const vector<uint8_t> private_key = hex_decode(PRIVATE_KEY);
      std::vector<uint8_t> data = hex_decode(TEXT);
  
      BigInt bprikey(private_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bprikey);
      // ECDSA_PublicKey pubkey(prikey);
  
      // // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature: 77A75FD1894F4113B5904CE6FBB8819B658856266FFCE3417C799C8E9163D87865CC4D12F3504181C53BAE8C1D497764E47080B73C72764D5F6E717C48E08896

** Existing key - Signature check - TEXT input
#+HEADER: :var TEXT        = "test msg"
#+HEADER: :var PRIVATE_KEY = "DBC868EF66949314FC040180FC6F1A9867466028364140361FF770733B23EF76"
#+HEADER: :var PUBLIC_KEY  = "04A9A712C7B56F3C878F230C6F6F31564D11D29F9E30A146E7F99904F6FD743708662C3B989201E6437F9DC261AF500F68C93EF2382F93F9B842E679F5297C1907"
#+HEADER: :var SIGNATURE   = "AC2527E96694CC18BD9A89D1F101CEC292887BC79EE1BD5D9E20CC0E67DFB26C5E486FE5535811368C7D88490399C91D478321A04F05E9C9E265EC1416A41185"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      Botan::AutoSeeded_RNG rng;

      const vector<uint8_t> private_key = hex_decode(PRIVATE_KEY);
      const vector<uint8_t> public_key = hex_decode(PUBLIC_KEY);

      BigInt bprikey(private_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bprikey);
      ECDSA_PublicKey pubkey(prikey);

      vector<uint8_t> pubk = pubkey.public_key_bits() ;
      if (hex_encode(pubk) != PUBLIC_KEY) {
          cout << "Invalid key pair." << endl;
          return 0;
      }

      std::string text(TEXT);
      std::vector<uint8_t> data(text.data(),text.data()+text.length());

      // verify signature
      Botan::PK_Verifier verifier(pubkey, "EMSA1(SHA-256)");
      verifier.update(data);
      std::cout << "Signature " << (verifier.check_signature(hex_decode(SIGNATURE))? "valid" : "invalid");

      return 0;
  }
#+end_src

#+RESULTS:
: Signature valid
** Existing key - Signature check - HEX input
#+HEADER: :var TEXT        = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var PRIVATE_KEY = "DBC868EF66949314FC040180FC6F1A9867466028364140361FF770733B23EF76"
#+HEADER: :var PUBLIC_KEY  = "04A9A712C7B56F3C878F230C6F6F31564D11D29F9E30A146E7F99904F6FD743708662C3B989201E6437F9DC261AF500F68C93EF2382F93F9B842E679F5297C1907"
#+HEADER: :var SIGNATURE   = "999ED1ADF893B7E4812D43AF1205FCAC40B55FAEA44EEAF0B040F4596D7DA0AD3767A2381D288EFB5F2B7684F9A385710653B2C1E094B9C9DEF8A3898F734C78"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      Botan::AutoSeeded_RNG rng;

      const vector<uint8_t> private_key = hex_decode(PRIVATE_KEY);
      const vector<uint8_t> public_key = hex_decode(PUBLIC_KEY);
      std::vector<uint8_t> data = hex_decode(TEXT);

      BigInt bprikey(private_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bprikey);
      ECDSA_PublicKey pubkey(prikey);

      vector<uint8_t> pubk = pubkey.public_key_bits() ;
      if (hex_encode(pubk) != PUBLIC_KEY) {
          cout << "Invalid key pair." << endl;
          return 0;
      }

      // verify signature
      Botan::PK_Verifier verifier(pubkey, "EMSA1(SHA-256)");
      verifier.update(data);
      std::cout << "Signature " << (verifier.check_signature(hex_decode(SIGNATURE))? "valid" : "invalid");

      return 0;
  }
#+end_src

#+RESULTS:
: Signature valid
** Existing key - Signature check - HEX input with only Public key
#+HEADER: :var TEXT        = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var PUBLIC_KEY  = "04A9A712C7B56F3C878F230C6F6F31564D11D29F9E30A146E7F99904F6FD743708662C3B989201E6437F9DC261AF500F68C93EF2382F93F9B842E679F5297C1907"
#+HEADER: :var SIGNATURE   = "999ED1ADF893B7E4812D43AF1205FCAC40B55FAEA44EEAF0B040F4596D7DA0AD3767A2381D288EFB5F2B7684F9A385710653B2C1E094B9C9DEF8A3898F734C78"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      Botan::AutoSeeded_RNG rng;
  
      const vector<uint8_t> public_key = hex_decode(PUBLIC_KEY);
      std::vector<uint8_t> data = hex_decode(TEXT);
      std::vector<uint8_t> sig = hex_decode(SIGNATURE);
  
      BigInt bpubkey(public_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bpubkey);
      ECDSA_PublicKey pubkey(prikey.algorithm_identifier(), public_key);
  
      // verify signature
      Botan::PK_Verifier verifier(pubkey, "EMSA1(SHA-256)");
      verifier.update(data);
      std::cout << "Signature " << (verifier.check_signature(sig)? "valid" : "invalid");
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature valid
* KDF
** SP-800-108 KDF
*** SP-800-108-Counter
#+HEADER: :var KI      = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var SALT    = "02"
#+HEADER: :var LABEL   = "03"
#+HEADER: :var KEY_LEN = 16
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <botan/kdf.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> ki1 = hex_decode(KI);
      vector<uint8_t> salt1 = hex_decode(SALT);
      vector<uint8_t> label1 = hex_decode(LABEL);

      secure_vector<uint8_t> ki(ki1.data(), ki1.data() + ki1.size());
      string salt(salt1.begin(), salt1.end());
      string label(label1.begin(), label1.end());

      unique_ptr<KDF> kdf = KDF::create("SP800-108-Counter(CMAC(AES-128))");
      secure_vector<uint8_t> dk = kdf->derive_key(KEY_LEN, ki, salt, label);

      cout << "Derived key: " << hex_encode(dk) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: Derived key: 1B258D35FCA9D012E7D3B7A506FBA3A4

*** SP-800-108-Counter using AES-128 CMAC
This is to make note how the Botan SP-800-108-Counter works under the
hood. (Binary rep of i = 01 case only)
#+HEADER: :var KI  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var LABEL = "03"
#+HEADER: :var CONTEXT = "02"
#+HEADER: :var KEY_LEN = 16
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      vector<uint8_t> ki = hex_decode(KI);
      vector<uint8_t> iv = hex_decode("");
      vector<uint8_t> label = hex_decode(LABEL);
      vector<uint8_t> context = hex_decode(CONTEXT);
      vector<uint8_t> seperator{ 0x00 };
      vector<uint8_t> i2{ 0,0,0,1 };

      int keyLen = KEY_LEN * 8;
      uint8_t l2_2 = (keyLen>>8) & 0xFF;
      uint8_t l2_3 =  keyLen & 0xFF;
      vector<uint8_t> l2{ 0, 0, l2_2, l2_3 };

      vector<uint8_t> data;
      data.insert(data.end(), i2.begin(), i2.end());
      data.insert(data.end(), label.begin(), label.end());
      data.insert(data.end(), seperator.begin(), seperator.end());
      data.insert(data.end(), context.begin(), context.end());
      data.insert(data.end(), l2.begin(), l2.end());

      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("CMAC(AES-128)"));
      if(!mac)
          return 1;

      mac->set_key(ki);
      mac->start(iv);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << "Derived key : " << hex_encode(tag) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: Derived key : 1B258D35FCA9D012E7D3B7A506FBA3A4

#+end_src
** PBKDF2
*** PBKDF2 - Text passphrase
#+HEADER: :var PASSPHRASE = "abcd"
#+HEADER: :var SALT       = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var ITERATION  = 1001
#+HEADER: :var KEY_LEN    = 32
#+begin_src C++
  #include <botan/pwdhash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> salt = hex_decode(SALT);

      auto pwd_fam = PasswordHashFamily::create_or_throw("PBKDF2(SHA-256)");
      auto pwd = pwd_fam->from_params(ITERATION);

      vector<uint8_t> key_vec(KEY_LEN);
      std::span key{key_vec.data(), key_vec.size()};
      pwd->hash(key, PASSPHRASE, salt);

      cout << "Derived key: " << hex_encode(key) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: Derived key: DECF9EF197B87ABBDB6CBA9E81A7BCB8AC36BB2BFA3B93746C8042227A27CFEA

*** PBKDF2 - HEX passphrase
#+HEADER: :var PASSPHRASE = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var SALT       = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var ITERATION  = 1001
#+HEADER: :var KEY_LEN    = 32
#+begin_src C++
  #include <botan/pwdhash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> salt = hex_decode(SALT);
      vector<uint8_t> pass1 = hex_decode(PASSPHRASE);
      string pass(pass1.begin(), pass1.end());

      auto pwd_fam = PasswordHashFamily::create_or_throw("PBKDF2(SHA-256)");
      auto pwd = pwd_fam->from_params(ITERATION);

      vector<uint8_t> key_vec(KEY_LEN);
      std::span key{key_vec.data(), key_vec.size()};
      pwd->hash(key, pass, salt);

      cout << "Derived key: " << hex_encode(key) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: Derived key: 9CA9E2C9F93EA70B744F9F751637B6C4EA7841F27BFF884902BF5CB48690F229

* RSA
** Demo
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/rsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      std::string text("testmsg");
      std::vector<uint8_t> data(text.data(),text.data()+text.length());

      Botan::AutoSeeded_RNG rng;

      // Generate RSA keypair
      Botan::RSA_PrivateKey prikey(rng, 2048);
      Botan::RSA_PublicKey pubkey(prikey);

      secure_vector<uint8_t> prik = prikey.private_key_bits();
      cout << "prikey: " << hex_encode(prik) << endl;
      BigInt pric = prikey.get_c();
      BigInt prid = prikey.get_d();
      BigInt prid1 = prikey.get_d1();
      BigInt prid2 = prikey.get_d2();
      BigInt prie = prikey.get_e();
      BigInt prin = prikey.get_n();
      BigInt prip = prikey.get_p();
      BigInt priq = prikey.get_q();
      cout << "prikey_c: " << pric.to_hex_string() << endl;
      cout << "prikey_d: " << prid.to_hex_string() << endl;
      cout << "prikey_d1: " << prid1.to_hex_string() << endl;
      cout << "prikey_d2: " << prid2.to_hex_string() << endl;
      cout << "prikey_e: " << prie.to_hex_string() << endl;
      cout << "prikey_n: " << prin.to_hex_string() << endl;
      cout << "prikey_p: " << prip.to_hex_string() << endl;
      cout << "prikey_q: " << priq.to_hex_string() << endl;

      // // Public key generated from private key
      vector<uint8_t> pubk = pubkey.public_key_bits();
      cout << "pubkey1: " << hex_encode(pubk) << endl;

      // // Pubic key value from private key
      vector<uint8_t> pubk2 = prikey.public_key_bits() ;
      cout << "pubkey2: " << hex_encode(pubk2) << endl;

      BigInt pube = pubkey.get_e();
      BigInt pubn = pubkey.get_n();
      cout << "pubkey_e: " << pube.to_hex_string() << endl;
      cout << "pubkey_n: " << pubn.to_hex_string() << endl;

      // // sign data
      Botan::PK_Signer signer(prikey, rng, "PSS(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;

      // // verify signature
      Botan::PK_Verifier verifier(pubkey, "PSS(SHA-256)");
      verifier.update(data);
      std::cout << "signature " << (verifier.check_signature(signature)? "valid" : "invalid");

      return 0;
  }
#+end_src

#+RESULTS:
| prikey:    | 308204A30201000282010100A71E7E805B30F9CB10D2385A5676E63F1B403E4C0FF885E0D22765B6F241696C6E2CC98031EACA158B9A097DE763F0B0611BC5A7CF009DEEC27D3F00063C3DB4F8810F7868F4C77F5C52A88432CA3A7E4BDDFBA4B44855387FC0816AEB615C762F3B0B0FBAB99DCFABC2A8C0EFAA24C9FA038B9E841B23B83D081367DAFBFAF0D236483379B17481C16256B5D74FCA24E1523F5CF8D711E1A8E1E31671A23D793E8F652F8C54301534D78D3CCC2CCCA33EF35B3739C7A68AEBF628EC4616133D31008371F7F758AAD812037D09D41062817424A29D5CEEDE12E2BB369AD97EB60CEBEB9600CB5E87B47A50EC2CFD6EE11C5593DA98A46E9068AED5E42AF8DA550203010001028201004E80BF18C97D80A198B5BF7E0426D732A6B8EF6AA887EC4FB7388589C253E2D36A0FC4D9E0D8F373DA7F91DCE050AC941611C72FF447CC688758F13AB033252379269B1F4B624CC2719A6C89A918211109CF6D71A9B45EBFEB17015439DCA2E3EB7CD74DDCBF6BB7CD6DE3FAB9BA598CBD52640822F362BC9D82C926DC91C8870C4BD1158856AEE6E0BD5ED5605F6530F7A907D1E7D38367EA5AC2A6E6331D0155DB1B66545113E08038BDF9F145E0282D11C99751328DD43B4B3C1E41C85AE8B9D458ACCC25BAAB2C94454A60C53E6FBAB09B84CC69F5047BC71223486A46A8EC5ED278E8482BE0691AE526F3313E45610E5777E584F97A05B7FA89D8A262D302818100D03693DD74D8BA926DF85F7964910C7258FACADCB48A2E90FDA93AC012F263D9717385138999DB037D41B3745374D9F48CBE14DF5E36764B5756F459F127AA53C6624722064658CC2A277E024302386649904EB2DADE5B1ACED42C88DD6A45E11BAE28ABC591B14B2FB6FA4B12E18BB38595272146C2E7174FDEDC45CFC232C302818100CD79766603BF441E6FCC13A934CEE6DF8CE2D875936C8A13A9D4C64F45032BB53D6FC0B6E1FF98732BC80AC3BDF7DEDFCC41CD07B7C2DFBD0CACAE7858A8EF7DA71049C848EAEE81F66535FD508118F37B5293B63DC4587E6902CDCECB478A10B5E2F8021852F57F91457574DF61EE175EFB31ED2C0125285E0F821FF41B3D07028180057A2A119D4D463B2BE168C18CBFB4101DFF1AEF0B60C730D13B6E6C371361450B12FAE134B1736D78120E6274FF91EC38F7971CF9217DA325BD07D885DB81438AE872EE9633AB8A53618E9308A83A4B968BD1462B33C639C24F1A8CCF2648884F6E196BCB5AB5CB408A13B37DDFA90923EE74850F9378F8C80518CE4D54D279028181008245C32254B7DC696BBA38B0EBF14E0168229ED894BA9924746599C1C2608B42A28C0AE4288F53C999758015B088C9FE9C530FBA17F0EEC7BE94711D8E20B58EB5F026C75C2BCF4208C50CA0E97CA024270928EBBF67902FBD4670D3EEA011D21C6FA58C367DCA76B1D516EE1D7ECA6478ECCC2FB1D99C0466F6702AF02AA0DB028180454D8EB3D591DDB34E3A1FEDCF7023016D74F64657F2AA6B59B96430BCC6AF9D066DFAACD1734877630096F902D4344F4BC45AA76F7D9B8731EABF8612D5E379F76C825D94B57A5DD4B7A1071D86D75DD6A3A0FFF55DD2CEF2D882FBACEB86B873F9D08FFF7EE9FE3CC804FF28B80CF9C0680480500173687B88C4DAC8D1F77E |
| prikey_c:  | 0x454D8EB3D591DDB34E3A1FEDCF7023016D74F64657F2AA6B59B96430BCC6AF9D066DFAACD1734877630096F902D4344F4BC45AA76F7D9B8731EABF8612D5E379F76C825D94B57A5DD4B7A1071D86D75DD6A3A0FFF55DD2CEF2D882FBACEB86B873F9D08FFF7EE9FE3CC804FF28B80CF9C0680480500173687B88C4DAC8D1F77E |
| prikey_d:  | 0x4E80BF18C97D80A198B5BF7E0426D732A6B8EF6AA887EC4FB7388589C253E2D36A0FC4D9E0D8F373DA7F91DCE050AC941611C72FF447CC688758F13AB033252379269B1F4B624CC2719A6C89A918211109CF6D71A9B45EBFEB17015439DCA2E3EB7CD74DDCBF6BB7CD6DE3FAB9BA598CBD52640822F362BC9D82C926DC91C8870C4BD1158856AEE6E0BD5ED5605F6530F7A907D1E7D38367EA5AC2A6E6331D0155DB1B66545113E08038BDF9F145E0282D11C99751328DD43B4B3C1E41C85AE8B9D458ACCC25BAAB2C94454A60C53E6FBAB09B84CC69F5047BC71223486A46A8EC5ED278E8482BE0691AE526F3313E45610E5777E584F97A05B7FA89D8A262D3 |
| prikey_d1: | 0x057A2A119D4D463B2BE168C18CBFB4101DFF1AEF0B60C730D13B6E6C371361450B12FAE134B1736D78120E6274FF91EC38F7971CF9217DA325BD07D885DB81438AE872EE9633AB8A53618E9308A83A4B968BD1462B33C639C24F1A8CCF2648884F6E196BCB5AB5CB408A13B37DDFA90923EE74850F9378F8C80518CE4D54D279 |
| prikey_d2: | 0x8245C32254B7DC696BBA38B0EBF14E0168229ED894BA9924746599C1C2608B42A28C0AE4288F53C999758015B088C9FE9C530FBA17F0EEC7BE94711D8E20B58EB5F026C75C2BCF4208C50CA0E97CA024270928EBBF67902FBD4670D3EEA011D21C6FA58C367DCA76B1D516EE1D7ECA6478ECCC2FB1D99C0466F6702AF02AA0DB |
| prikey_e:  |                                                                                           0x010001 |
| prikey_n:  | 0xA71E7E805B30F9CB10D2385A5676E63F1B403E4C0FF885E0D22765B6F241696C6E2CC98031EACA158B9A097DE763F0B0611BC5A7CF009DEEC27D3F00063C3DB4F8810F7868F4C77F5C52A88432CA3A7E4BDDFBA4B44855387FC0816AEB615C762F3B0B0FBAB99DCFABC2A8C0EFAA24C9FA038B9E841B23B83D081367DAFBFAF0D236483379B17481C16256B5D74FCA24E1523F5CF8D711E1A8E1E31671A23D793E8F652F8C54301534D78D3CCC2CCCA33EF35B3739C7A68AEBF628EC4616133D31008371F7F758AAD812037D09D41062817424A29D5CEEDE12E2BB369AD97EB60CEBEB9600CB5E87B47A50EC2CFD6EE11C5593DA98A46E9068AED5E42AF8DA55 |
| prikey_p:  | 0xD03693DD74D8BA926DF85F7964910C7258FACADCB48A2E90FDA93AC012F263D9717385138999DB037D41B3745374D9F48CBE14DF5E36764B5756F459F127AA53C6624722064658CC2A277E024302386649904EB2DADE5B1ACED42C88DD6A45E11BAE28ABC591B14B2FB6FA4B12E18BB38595272146C2E7174FDEDC45CFC232C3 |
| prikey_q:  | 0xCD79766603BF441E6FCC13A934CEE6DF8CE2D875936C8A13A9D4C64F45032BB53D6FC0B6E1FF98732BC80AC3BDF7DEDFCC41CD07B7C2DFBD0CACAE7858A8EF7DA71049C848EAEE81F66535FD508118F37B5293B63DC4587E6902CDCECB478A10B5E2F8021852F57F91457574DF61EE175EFB31ED2C0125285E0F821FF41B3D07 |
| pubkey1:   | 3082010A0282010100A71E7E805B30F9CB10D2385A5676E63F1B403E4C0FF885E0D22765B6F241696C6E2CC98031EACA158B9A097DE763F0B0611BC5A7CF009DEEC27D3F00063C3DB4F8810F7868F4C77F5C52A88432CA3A7E4BDDFBA4B44855387FC0816AEB615C762F3B0B0FBAB99DCFABC2A8C0EFAA24C9FA038B9E841B23B83D081367DAFBFAF0D236483379B17481C16256B5D74FCA24E1523F5CF8D711E1A8E1E31671A23D793E8F652F8C54301534D78D3CCC2CCCA33EF35B3739C7A68AEBF628EC4616133D31008371F7F758AAD812037D09D41062817424A29D5CEEDE12E2BB369AD97EB60CEBEB9600CB5E87B47A50EC2CFD6EE11C5593DA98A46E9068AED5E42AF8DA550203010001 |
| pubkey2:   | 3082010A0282010100A71E7E805B30F9CB10D2385A5676E63F1B403E4C0FF885E0D22765B6F241696C6E2CC98031EACA158B9A097DE763F0B0611BC5A7CF009DEEC27D3F00063C3DB4F8810F7868F4C77F5C52A88432CA3A7E4BDDFBA4B44855387FC0816AEB615C762F3B0B0FBAB99DCFABC2A8C0EFAA24C9FA038B9E841B23B83D081367DAFBFAF0D236483379B17481C16256B5D74FCA24E1523F5CF8D711E1A8E1E31671A23D793E8F652F8C54301534D78D3CCC2CCCA33EF35B3739C7A68AEBF628EC4616133D31008371F7F758AAD812037D09D41062817424A29D5CEEDE12E2BB369AD97EB60CEBEB9600CB5E87B47A50EC2CFD6EE11C5593DA98A46E9068AED5E42AF8DA550203010001 |
| pubkey_e:  |                                                                                           0x010001 |
| pubkey_n:  | 0xA71E7E805B30F9CB10D2385A5676E63F1B403E4C0FF885E0D22765B6F241696C6E2CC98031EACA158B9A097DE763F0B0611BC5A7CF009DEEC27D3F00063C3DB4F8810F7868F4C77F5C52A88432CA3A7E4BDDFBA4B44855387FC0816AEB615C762F3B0B0FBAB99DCFABC2A8C0EFAA24C9FA038B9E841B23B83D081367DAFBFAF0D236483379B17481C16256B5D74FCA24E1523F5CF8D711E1A8E1E31671A23D793E8F652F8C54301534D78D3CCC2CCCA33EF35B3739C7A68AEBF628EC4616133D31008371F7F758AAD812037D09D41062817424A29D5CEEDE12E2BB369AD97EB60CEBEB9600CB5E87B47A50EC2CFD6EE11C5593DA98A46E9068AED5E42AF8DA55 |
| Signature: | 377286DC4C02832208FD6B3717BC3D8714AD155CECD44E026BB4E3CA9BD349DBB83EC1A62160B966057D324407725099C223EB74F369A57757E4E81923F78292BBC5BD8BE82F78E48C190EAA7A6D77FE373B384F0FFECA7A91B9DBCA1AACC084DB8523A69F1F688B5162DABBEA30A077F5061E30BC07FC30E3B0D9A85559BEB409B8994C8401A0D83DDCAF127028259950186AEAC961241C450C8A59FE023F94518208EF144AD11F5229654F8FE4BE2899E55822CAD426273A01E1780B3D507A9853DB5A9742A207C98C5A6FE739CBCA24EEDB4CAF0D0B6C18F0D7759E8930254F3F45DEC483E9C5ACB33E616A7BDB6F85EA05D71C043A67DF4B3F30B4B64DE1 |
| signature  |                                                                                              valid |

** Encrypt
#+HEADER: :var HEX_M = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var VAL_E = "010001"
#+HEADER: :var VAL_P = "E59E29CDC32B5186392D4A2339FBCBD47049D3A1BA3E2EE35361D8B0AECE2ACB7250F6B9454AF59F4346E669D07CAD1D77E80B2C7767B5324EA1C30390D928745A79AEAE50094CD337A45C68A3FAA46ACEFE842C99B7AD8A81990F6CD5A60D09B81C4BEF45A4A197F557F83C3806CC9B3B38454B6EAA65EEFDA2BF76CE585555"
#+HEADER: :var VAL_Q = "D4B922F0A78FFC21FFD9525481464CE1E498D5A6053A39AD5D91975EC27188A9360BEFFCCF4B4ACFDF052E5AA3D6A87DA16E31C2805EA5CC803191D981092F8D8EC014595971A394998A2B0D4061ED7BE0047B2FD2A24AD8725AD3353D3A49D3F0104160DD5EBA9101F27B6DAD3DF9555A8C424C83DB37EAA7EB31CE5869E739"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/rsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/rng.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      const vector<uint8_t> hexM = hex_decode(HEX_M);
      const vector<uint8_t> valE = hex_decode(VAL_E);
      const vector<uint8_t> valP = hex_decode(VAL_P);
      const vector<uint8_t> valQ = hex_decode(VAL_Q);
  
      AutoSeeded_RNG rng;
  
      BigInt e(valE);
      BigInt p(valP);
      BigInt q(valQ);
      BigInt n(p * q);
  
      Botan::RSA_PublicKey pubkey(n, e);
  
      //encrypt with pk
      Botan::PK_Encryptor_EME enc(pubkey, rng, "OAEP(SHA-256)");
      std::vector<uint8_t> ct = enc.encrypt(hexM, rng);
  
      cout << "Enc: " << hex_encode(ct) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Enc: 93A8D54451E83FB53D4FBFCD16DF835AB9E39C227EC229BC65D24ED4AA1777E2C60A2DD8784EC8D2C341DA15FE7898800B6EEFEF07E6E4FF2250908A9694968182B7C849631F6D1F101ACC5F8308A62EE6E3AFE39A1CE235F2C6FE82490681150CEE9E4F7C90ECCC442D05AB1F43F0414D5C1FBFF8D5C66F6D2DEB3D711F5C827EBBB01266E3B84E9DD451FF4E5AF9BD005A6F62B96184D95756CC94A7B117300A4354034DEDFA65D130405975DADF06EC188DD60D8EEE33ECD2C55428D973C2DEDE259B254EF941193FF0F4327AB056A2B685CA4F0889A9B090703A74039BA29989D25200D0E6796B377021728582BB4BD7E342753B42F5392CCD78B590B0A9

** Decrypt
#+HEADER: :var ENC_M = "93A8D54451E83FB53D4FBFCD16DF835AB9E39C227EC229BC65D24ED4AA1777E2C60A2DD8784EC8D2C341DA15FE7898800B6EEFEF07E6E4FF2250908A9694968182B7C849631F6D1F101ACC5F8308A62EE6E3AFE39A1CE235F2C6FE82490681150CEE9E4F7C90ECCC442D05AB1F43F0414D5C1FBFF8D5C66F6D2DEB3D711F5C827EBBB01266E3B84E9DD451FF4E5AF9BD005A6F62B96184D95756CC94A7B117300A4354034DEDFA65D130405975DADF06EC188DD60D8EEE33ECD2C55428D973C2DEDE259B254EF941193FF0F4327AB056A2B685CA4F0889A9B090703A74039BA29989D25200D0E6796B377021728582BB4BD7E342753B42F5392CCD78B590B0A9"
#+HEADER: :var VAL_E = "010001"
#+HEADER: :var VAL_P = "E59E29CDC32B5186392D4A2339FBCBD47049D3A1BA3E2EE35361D8B0AECE2ACB7250F6B9454AF59F4346E669D07CAD1D77E80B2C7767B5324EA1C30390D928745A79AEAE50094CD337A45C68A3FAA46ACEFE842C99B7AD8A81990F6CD5A60D09B81C4BEF45A4A197F557F83C3806CC9B3B38454B6EAA65EEFDA2BF76CE585555"
#+HEADER: :var VAL_Q = "D4B922F0A78FFC21FFD9525481464CE1E498D5A6053A39AD5D91975EC27188A9360BEFFCCF4B4ACFDF052E5AA3D6A87DA16E31C2805EA5CC803191D981092F8D8EC014595971A394998A2B0D4061ED7BE0047B2FD2A24AD8725AD3353D3A49D3F0104160DD5EBA9101F27B6DAD3DF9555A8C424C83DB37EAA7EB31CE5869E739"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/rsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/rng.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      const vector<uint8_t> hexM = hex_decode(ENC_M);
      const vector<uint8_t> valE = hex_decode(VAL_E);
      const vector<uint8_t> valP = hex_decode(VAL_P);
      const vector<uint8_t> valQ = hex_decode(VAL_Q);
  
      AutoSeeded_RNG rng;
  
      BigInt e(valE);
      BigInt p(valP);
      BigInt q(valQ);
  
      Botan::RSA_PrivateKey prikey(p, q, e);
      BigInt prid = prikey.get_d();
  
      //encrypt with pk
      Botan::PK_Decryptor_EME dec(prikey, rng, "OAEP(SHA-256)");
      secure_vector<uint8_t> pt = dec.decrypt(hexM);
  
      cout << "Dec: " << hex_encode(pt) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Dec: 000102030405060708090A0B0C0D0E0F

** Sign
#+HEADER: :var HEX_M = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var VAL_E = "010001"
#+HEADER: :var VAL_P = "E59E29CDC32B5186392D4A2339FBCBD47049D3A1BA3E2EE35361D8B0AECE2ACB7250F6B9454AF59F4346E669D07CAD1D77E80B2C7767B5324EA1C30390D928745A79AEAE50094CD337A45C68A3FAA46ACEFE842C99B7AD8A81990F6CD5A60D09B81C4BEF45A4A197F557F83C3806CC9B3B38454B6EAA65EEFDA2BF76CE585555"
#+HEADER: :var VAL_Q = "D4B922F0A78FFC21FFD9525481464CE1E498D5A6053A39AD5D91975EC27188A9360BEFFCCF4B4ACFDF052E5AA3D6A87DA16E31C2805EA5CC803191D981092F8D8EC014595971A394998A2B0D4061ED7BE0047B2FD2A24AD8725AD3353D3A49D3F0104160DD5EBA9101F27B6DAD3DF9555A8C424C83DB37EAA7EB31CE5869E739"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/rsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      const vector<uint8_t> hexM = hex_decode(HEX_M);
      const vector<uint8_t> valE = hex_decode(VAL_E);
      const vector<uint8_t> valP = hex_decode(VAL_P);
      const vector<uint8_t> valQ = hex_decode(VAL_Q);
  
      AutoSeeded_RNG rng;
  
      BigInt e(valE);
      BigInt p(valP);
      BigInt q(valQ);
  
      Botan::RSA_PrivateKey prikey(p, q, e);
  
      BigInt prid = prikey.get_d();
  
      // // sign data
      Botan::PK_Signer signer(prikey, rng, "PSS(SHA-256)");
      signer.update(hexM);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature: B38E9F45CC125796DE43E671144FB648146E23DD4444E24F37957A6798571D23605E423E1BF538F8DE3E93A049BD147E88CEE689A65A813ABEDCB307FAFCD6E82B766C4E3619E74D58A4ADE8CAF305B365B5B4EA751315EB2D3FD907D8E2B37BEDBB449A6E24E44D48E7E776E6003CE395530C30B0DC47BC8402EF4821BE5E5BCE67545F891F216A62F89E2CBF040112F611C5190E927A960BBCD64E3C6F8C7FE90D0E4A9C4FE6A8F22A810864245BFEBF45062FCB678ADF53563E66105B67EE589A7412BE8D4011D9523D5DECBB8659D23B862A47C583BE8985A82DCF40CAD42DE0E1AD8E385C61EAAD2113819F61DB966390800727409EED2824F5E3C21194

** Verify
#+HEADER: :var SIGN  = "B38E9F45CC125796DE43E671144FB648146E23DD4444E24F37957A6798571D23605E423E1BF538F8DE3E93A049BD147E88CEE689A65A813ABEDCB307FAFCD6E82B766C4E3619E74D58A4ADE8CAF305B365B5B4EA751315EB2D3FD907D8E2B37BEDBB449A6E24E44D48E7E776E6003CE395530C30B0DC47BC8402EF4821BE5E5BCE67545F891F216A62F89E2CBF040112F611C5190E927A960BBCD64E3C6F8C7FE90D0E4A9C4FE6A8F22A810864245BFEBF45062FCB678ADF53563E66105B67EE589A7412BE8D4011D9523D5DECBB8659D23B862A47C583BE8985A82DCF40CAD42DE0E1AD8E385C61EAAD2113819F61DB966390800727409EED2824F5E3C21194"
#+HEADER: :var HEX_M = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var VAL_E = "010001"
#+HEADER: :var VAL_P = "E59E29CDC32B5186392D4A2339FBCBD47049D3A1BA3E2EE35361D8B0AECE2ACB7250F6B9454AF59F4346E669D07CAD1D77E80B2C7767B5324EA1C30390D928745A79AEAE50094CD337A45C68A3FAA46ACEFE842C99B7AD8A81990F6CD5A60D09B81C4BEF45A4A197F557F83C3806CC9B3B38454B6EAA65EEFDA2BF76CE585555"
#+HEADER: :var VAL_Q = "D4B922F0A78FFC21FFD9525481464CE1E498D5A6053A39AD5D91975EC27188A9360BEFFCCF4B4ACFDF052E5AA3D6A87DA16E31C2805EA5CC803191D981092F8D8EC014595971A394998A2B0D4061ED7BE0047B2FD2A24AD8725AD3353D3A49D3F0104160DD5EBA9101F27B6DAD3DF9555A8C424C83DB37EAA7EB31CE5869E739"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/rsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      const vector<uint8_t> signature = hex_decode(SIGN);
      const vector<uint8_t> hexM = hex_decode(HEX_M);
      const vector<uint8_t> valE = hex_decode(VAL_E);
      const vector<uint8_t> valP = hex_decode(VAL_P);
      const vector<uint8_t> valQ = hex_decode(VAL_Q);
  
      AutoSeeded_RNG rng;
  
      BigInt e(valE);
      BigInt p(valP);
      BigInt q(valQ);
      BigInt n(p * q);
  
      Botan::RSA_PublicKey pubkey(n, e);
  
      // // verify signature
      Botan::PK_Verifier verifier(pubkey, "PSS(SHA-256)");
      verifier.update(hexM);
      std::cout << "Signature " << (verifier.check_signature(signature)? "Valid" : "Invalid");
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature Valid
