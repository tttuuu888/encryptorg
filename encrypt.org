#+STARTUP: hideblocks
#+PROPERTY: header-args :libs -I/usr/include/botan-2 -lbotan-2
* SHA-256
** Plain text input
#+HEADER: :var TEXT = "abcd"
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>
  #include <sstream>
  #include <vector>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      unique_ptr<HashFunction> hash1(HashFunction::create("SHA-256"));

      string plain = TEXT;
      hash1->update(plain);

      cout << "SHA-256: " << hex_encode(hash1->final()) << endl;
      return 0;
  }
#+end_src

#+RESULTS:
: SHA-256: 88D4266FD4E6338D13B845FCF289579D209C897823B9217DA3E161936F031589

** Hex input
#+HEADER: :var INPUT = "01020304"
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>
  #include <sstream>
  #include <string>
  #include <vector>
  //#include <boost/algorithm/hex.hpp>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      unique_ptr<HashFunction> hash1(HashFunction::create("SHA-256"));

      string input = INPUT;
      vector<uint8_t> vec = hex_decode(input);

      hash1->update(vec);

      cout << "SHA-256: " << hex_encode(hash1->final()) << endl;
      return 0;
  }
#+end_src

#+RESULTS:
: SHA-256: 9F64A747E1B97F131FABB6B447296C9B6F0201E79FB3C5356E6C77E89B6A806A

** Plain text repeat
#+HEADER: :var REPEAT_COUNT = 10
#+HEADER: :var TEXT = "abcd"
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>
  #include <sstream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      unique_ptr<HashFunction> hash1(HashFunction::create("SHA-256"));

      string plain = TEXT;

      for(auto i=0; i<REPEAT_COUNT; i++)
          hash1->update(plain);

      cout << "SHA-256: " << hex_encode(hash1->final()) << endl;
      return 0;
  }
#+end_src

#+RESULTS:
: SHA-256: 38986FC4DEFA1CD49321AD652FF3A02A36EBE62E5EE62C0696AC8F86F76DFA36

** Hex repeat
#+HEADER: :var REPEAT_COUNT = 10
#+HEADER: :var INPUT = "01020304"
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>
  #include <sstream>
  #include <string>
  #include <vector>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      unique_ptr<HashFunction> hash1(HashFunction::create("SHA-256"));
      vector<uint8_t> vec = hex_decode(INPUT);

      for(auto i=0; i<REPEAT_COUNT; i++)
          hash1->update(vec);

      cout << "SHA-256: " << hex_encode(hash1->final()) << endl;
      return 0;
  }
#+end_src

#+RESULTS:
: SHA-256: C7C31ED6686BB62C7981C0FFC16759F7E60FB95231C847964D2674A4D269FE72
* MAC
** HMAC-256 hex input
#+HEADER: :var KEY = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var MSG = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <botan/mac.h>
  #include <iostream>
  #include <vector>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> msg = hex_decode(MSG);

      auto hmac = Botan::MessageAuthenticationCode::create_or_throw("HMAC(SHA-256)");

      hmac->set_key(key); hmac->update(msg);

      auto ret = Botan::hex_encode(hmac->final());

      cout << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: B7FB0BE696FEAEC6F647F2F2A7B887944CF39546B1422105FB7FBEBC65787550

** AES-128 GMAC
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var DATA  = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> nonce = hex_decode(NONCE);
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("GMAC(AES-128)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // //Verify created MAC
      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| GMAC(AES-128): | 0474FA92425A16FA4404824A00398C74 |
| Verification:  | success                          |

#+end_src
** AES-256 GMAC
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var DATA  = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> nonce = hex_decode(NONCE);
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("GMAC(AES-256)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // //Verify created MAC
      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| GMAC(AES-256): | 65DC9D99AB0FF0F31351A169DC0EC101 |
| Verification:  | success                          |

#+end_src
** ARIA-128 GMAC
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var DATA  = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> nonce = hex_decode(NONCE);
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("GMAC(ARIA-128)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // //Verify created MAC
      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| GMAC(ARIA-128): | 62B01592621FEACB86CCCC541CC9D169 |
| Verification:   | success                          |

#+end_src
** ARIA-192 GMAC
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F0001020304050607"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var DATA  = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> nonce = hex_decode(NONCE);
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("GMAC(ARIA-192)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // //Verify created MAC
      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| GMAC(ARIA-192): | F0B6264439A0EBDD043ECFDED8A268E8 |
| Verification:   | success                          |

#+end_src
** ARIA-256 GMAC
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var DATA  = "102030405060708090A0B0C0D0E0F000"
#+begin_src C++
  #include <botan/mac.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> nonce = hex_decode(NONCE);
      const vector<uint8_t> data = hex_decode(DATA);
      unique_ptr<MessageAuthenticationCode> mac(MessageAuthenticationCode::create("GMAC(ARIA-256)"));

      if(!mac)
          return 1;

      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      secure_vector<uint8_t> tag = mac->final();
      cout << mac->name() << ": " << hex_encode(tag) << endl;

      // //Verify created MAC
      mac->set_key(key);
      mac->start(nonce);
      mac->update(data);
      cout << "Verification: " << (mac->verify_mac(tag) ? "success" : "failure");

      return 0;
  }
#+end_src

#+RESULTS:
| GMAC(ARIA-256): | E0DED6F693CEEFAE2C10DF84EDE5BC15 |
| Verification:   | success                          |

#+end_src
* AES
** AES-128
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> k = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));

      cipher->set_key(k);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128 Encrypt: 69C4E0D86A7B0430D8CDB78070B4C55A

*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "69C4E0D86A7B0430D8CDB78070B4C55A"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " Decrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128 Decrypt: 00112233445566778899AABBCCDDEEFF

** AES-192
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F0001020304050607"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-192"));

      cipher->set_key(key);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-192 Encrypt: 65D50128B115A7780981475A6BD64A0E

*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F0001020304050607"
#+HEADER: :var ENCRYPTED = "65D50128B115A7780981475A6BD64A0E"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-192"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-192 encrypt: 00112233445566778899AABBCCDDEEFF

** AES-256
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-256"));

      cipher->set_key(key);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-256 Encrypt: 8EA2B7CA516745BFEAFC49904B496089
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"
#+HEADER: :var ENCRYPTED = "8EA2B7CA516745BFEAFC49904B496089"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-256"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-256 encrypt: 00112233445566778899AABBCCDDEEFF
** AES-GCM-128
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/aes.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("AES-128/GCM", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_ad(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| AES-128/GCM(16) | Enc: | 565680A8B07A8E5AFE067D91B9168154 |
| AES-128/GCM(16) | Mac: | 343EF77F1C6DE85BB313B51E9AAD2291 |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "565680A8B07A8E5AFE067D91B9168154"
#+HEADER: :var INPUT_TAG = "343EF77F1C6DE85BB313B51E9AAD2291"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/aes.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("AES-128/GCM", DECRYPTION);

      dec->set_key(key);
      dec->set_ad(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
** AES-GCM-192
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF0011223344556677"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/ccm.h>
  #include <botan/aes.h>
  #include <botan/auto_rng.h>
  #include <botan/cipher_mode.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("AES-192/GCM", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_ad(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| AES-192/GCM(16) | Enc: | 545DD08DF08C14CA7100400B4A3833DD |
| AES-192/GCM(16) | Mac: | 94F0FA724CA153D25C5F95A007FC9BD6 |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF0011223344556677"
#+HEADER: :var ENCRYPTED = "545DD08DF08C14CA7100400B4A3833DD"
#+HEADER: :var INPUT_TAG = "94F0FA724CA153D25C5F95A007FC9BD6"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/aes.h>
  #include <botan/auto_rng.h>
  #include <botan/cipher_mode.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("AES-192/GCM", DECRYPTION);

      dec->set_key(key);
      dec->set_ad(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: AES-192/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
** AES-GCM-256
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/ccm.h>
  #include <botan/aes.h>
  #include <botan/auto_rng.h>
  #include <botan/cipher_mode.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("AES-256/GCM", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_ad(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| AES-256/GCM(16) | Enc: | D9AB5267E66C88BA53BD3EB1D877E958 |
| AES-256/GCM(16) | Mac: | C7FE61A04359304E950A454644C12C88 |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "D9AB5267E66C88BA53BD3EB1D877E958"
#+HEADER: :var INPUT_TAG = "C7FE61A04359304E950A454644C12C88"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/aes.h>
  #include <botan/auto_rng.h>
  #include <botan/cipher_mode.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("AES-256/GCM", DECRYPTION);

      dec->set_key(key);
      dec->set_ad(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: AES-256/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
*** Encrypt text string
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "string text input"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/ccm.h>
  #include <botan/aes.h>
  #include <botan/auto_rng.h>
  #include <botan/cipher_mode.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const string input(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("AES-256/GCM", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.length());

      enc->set_key(key);
      enc->set_ad(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| AES-256/GCM(16) | Enc: | BAFF104ED86BD84EA665FA5161F9692DA4 |
| AES-256/GCM(16) | Mac: | 5E11C2B9BBFBD7D4B4B84BDCF0DDB280   |
*** Decrypt to text string
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "BAFF104ED86BD84EA665FA5161F9692DA4"
#+HEADER: :var INPUT_TAG = "5E11C2B9BBFBD7D4B4B84BDCF0DDB280"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/aes.h>
  #include <botan/auto_rng.h>
  #include <botan/cipher_mode.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("AES-256/GCM", DECRYPTION);

      dec->set_key(key);
      dec->set_ad(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      std::string str(pt.begin(), pt.end());
      cout << dec->name() << " Dec: " << str << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: AES-256/GCM(16) Dec: string text input
** AES-CBC-128 NoPadding
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var IV   = "112233445566778899AABBCCDDEEFF00"
#+HEADER: :var TEXT = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/aes.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("AES-128/CBC/NoPadding", ENCRYPTION);
      // cout << " default nonce lengh " << enc->default_nonce_length() << endl;

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/CBC/NoPadding Enc: B6BE67EB61AF49AB060D80C4BDAFF7B4DAA5494EED201541D72B17AD40A95B0A
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var IV        = "112233445566778899AABBCCDDEEFF00"
#+HEADER: :var ENCRYPTED = "B6BE67EB61AF49AB060D80C4BDAFF7B4DAA5494EED201541D72B17AD40A95B0A"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/aes.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("AES-128/CBC/NoPadding", DECRYPTION);

      dec->set_key(key);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/CBC/NoPadding Dec: 000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F
** AES-CBC-128 PKCS7 Padding
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCCDDEEFF00"
#+begin_src C++
  #include <botan/cbc.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("AES-128/CBC/PKCS7", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/CBC/PKCS7 Enc: A28F5667E6CE191444647F5B2E570AE8644F7CE15636077CFB9ADD5CD87FC6C6
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "A28F5667E6CE191444647F5B2E570AE8644F7CE15636077CFB9ADD5CD87FC6C6"
#+HEADER: :var IV        = "112233445566778899AABBCCDDEEFF00"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("AES-128/CBC/PKCS7", DECRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: AES-128/CBC/PKCS7 Dec: 102030405060708090A0B0C0D0E0F000
** AES-CTR-128
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var IV   = "112233445566778899AABBCCDDEEFF00"
#+HEADER: :var TEXT = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/aes.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("AES-128/CTR", ENCRYPTION);
      // cout << " default nonce lengh " << enc->default_nonce_length() << endl;

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: CTR-BE(AES-128) Enc: 0DBFDF84A3810CE19DD7394598DE505F1E0ED42DFBBD7EB164BE5DA7F5CD5C23
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var IV        = "112233445566778899AABBCCDDEEFF00"
#+HEADER: :var ENCRYPTED = "0DBFDF84A3810CE19DD7394598DE505F1E0ED42DFBBD7EB164BE5DA7F5CD5C23"
#+begin_src C++
  #include <botan/cipher_mode.h>
  #include <botan/aes.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("AES-128/CTR", DECRYPTION);

      dec->set_key(key);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: CTR-BE(AES-128) Dec: 000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F
** AES-CCM-128
*** Encrypt
#+HEADER: :var KEY   = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var TEXT  = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var NONCE = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var AAD   = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/aes.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> nonce = hex_decode(NONCE);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("AES-128/CCM", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_ad(aad);
      enc->start(nonce);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| AES-128/CCM(16 | 3) Enc: 326AD41E63D474A45618919268C45AF2 |
| AES-128/CCM(16 | 3) Mac: FF60D3CC73E4E6EF95BBB13616C3AE27 |
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "326AD41E63D474A45618919268C45AF2"
#+HEADER: :var INPUT_TAG = "FF60D3CC73E4E6EF95BBB13616C3AE27"
#+HEADER: :var NONCE     = "FFFFFFFFFFFFFFFFFFFFFFFF"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/aes.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> nonce = hex_decode(NONCE);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("AES-128/CCM", DECRYPTION);

      dec->set_key(key);
      dec->set_ad(aad);
      dec->start(nonce);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
| AES-128/CCM(16 | 3) Dec: 102030405060708090A0B0C0D0E0F000 |
* AES key wrapper (RFC3394)
** Using botan interface
*** Demo
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var KEY = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <botan/nist_keywrap.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> key = hex_decode(KEY);

      uint8_t keyArr[key.size()];
      for(int i=0; i<key.size(); i++)
          keyArr[i] = key[i];

      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));
      cipher->set_key(kek);

      vector<uint8_t> wrappedKey = nist_key_wrap(keyArr, key.size(), *cipher);
      cout << "WrappedKey: " << hex_encode(wrappedKey) << endl;

      uint8_t wrappedKeyArr[wrappedKey.size()];
      for(int i=0; i<wrappedKey.size(); i++)
          wrappedKeyArr[i] = wrappedKey[i];

      secure_vector<uint8_t> restoredKey = nist_key_unwrap(wrappedKeyArr, wrappedKey.size(), *cipher);
      cout << "UnWrappedKey: " << hex_encode(restoredKey) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| WrappedKey:   | 1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5 |
| UnWrappedKey: | 00112233445566778899AABBCCDDEEFF                 |
*** Wrap
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var KEY = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <botan/nist_keywrap.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> key = hex_decode(KEY);

      uint8_t keyArr[key.size()];
      for(int i=0; i<key.size(); i++)
          keyArr[i] = key[i];

      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));
      cipher->set_key(kek);

      vector<uint8_t> wrappedKey = nist_key_wrap(keyArr, key.size(), *cipher);
      cout << "WrappedKey: " << hex_encode(wrappedKey) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: WrappedKey: 1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5
*** Unwrap
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var WRAPPED_KEY = "1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <botan/nist_keywrap.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> wrappedKey = hex_decode(WRAPPED_KEY);;

      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));
      cipher->set_key(kek);

      uint8_t wrappedKeyArr[wrappedKey.size()];
      for(int i=0; i<wrappedKey.size(); i++)
          wrappedKeyArr[i] = wrappedKey[i];

      secure_vector<uint8_t> restoredKey = nist_key_unwrap(wrappedKeyArr, wrappedKey.size(), *cipher);
      cout << "UnWrappedKey: " << hex_encode(restoredKey) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: UnWrappedKey: 00112233445566778899AABBCCDDEEFF
** Using implemented function
*** Wrapper functions
#+name: wrapper_functions
#+begin_src C++
  static vector<uint8_t> defaultIv{0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6};

  int keyWrapperWithIv(vector<uint8_t> &kek, vector<uint8_t> &key, vector<uint8_t> &wrappedKey, vector<uint8_t> &iv)
  {
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));
      cipher->set_key(kek);

      int n = key.size() / 8;
      uint8_t R[n+1][8] = {0,};
      vector<uint8_t> A = iv;

      for(int i=0; i<n; i++)
          std::copy(key.begin()+(i*8), key.begin()+(i*8)+8, R[i+1]);

      for(int j=0; j<=5; j++) {
          for(int i=1; i<=n; i++) {
              vector<uint8_t> B(A);
              B.insert(B.end(), R[i], R[i]+8);

              cipher->encrypt(B);

              A.clear();
              A.assign(B.begin(), B.begin()+8);

              int toXor = (n*j)+i, Ai = 7;
              while(toXor != 0) {
                  A[Ai] ^= (toXor & 0xFF);
                  Ai -= 1;
                  toXor >>= 8;
              }

              std::copy(B.begin()+8, B.end(), R[i]);
          }
      }

      wrappedKey.clear();
      wrappedKey.assign(A.begin(), A.end());

      for(int i=1; i<=n; i++)
          wrappedKey.insert(wrappedKey.end(), R[i], R[i]+8);

      cout << "Wrappedkey: " << hex_encode(wrappedKey) << endl;

      return 0;
  }

  int keyUnwrapperWithiv(vector<uint8_t> &kek, vector<uint8_t> &wrappedKey, vector<uint8_t> &key, vector<uint8_t> iv)
  {
      unique_ptr<BlockCipher> cipher(BlockCipher::create("AES-128"));
      cipher->set_key(kek);

      int n = wrappedKey.size() / 8 - 1;
      uint8_t R[n+2][8] = {0,};
      vector<uint8_t> A;
      A.assign(wrappedKey.begin(), wrappedKey.begin()+8);

      for(int i=1; i<n+1; i++)
          std::copy(wrappedKey.begin()+(i*8), wrappedKey.begin()+(i*8)+8, R[i]);

      for(int j=5; j>=0; j--) {
          for(int i=n; i>=1; i--) {
              int toXor = (n*j)+i, Ai = 7;
              while(toXor != 0) {
                  A[Ai] ^= (toXor & 0xFF);
                  Ai -= 1;
                  toXor >>= 8;
              }

              vector<uint8_t> B(A);
              B.insert(B.end(), R[i], R[i]+8);

              cipher->decrypt(B);

              A.clear();
              A.assign(B.begin(), B.begin()+8);

              std::copy(B.begin()+8, B.end(), R[i]);
          }
      }

      key.clear();
      key.insert(key.end(), R[1], R[1]+16);

      if(A != iv) {
          cout << "IV mismatch" << endl;
          return -1;
      }

      cout << "IV: " << hex_encode(A) << endl;
      cout << "OriginalKey: " << hex_encode(key) << endl;

      return 0;
  }


  int keyWrapper(vector<uint8_t> &kek, vector<uint8_t> &key, vector<uint8_t> &wrappedKey, vector<uint8_t> &iv)
  {
      keyWrapperWithIv(kek, key, wrappedKey, iv);
  }
  int keyWrapper(vector<uint8_t> &kek, vector<uint8_t> &key, vector<uint8_t> &wrappedKey)
  {
      keyWrapperWithIv(kek, key, wrappedKey, defaultIv);
  }

  int keyUnwrapper(vector<uint8_t> &kek, vector<uint8_t> &wrappedKey, vector<uint8_t> &key, vector<uint8_t> iv)
  {
      keyUnwrapperWithiv(kek, wrappedKey, key, iv);
  }
  int keyUnwrapper(vector<uint8_t> &kek, vector<uint8_t> &wrappedKey, vector<uint8_t> &key)
  {
      keyUnwrapperWithiv(kek, wrappedKey, key, defaultIv);
  }
#+end_src

*** Demo
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var KEY = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  <<wrapper_functions>>

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> wrappedKey;
      vector<uint8_t> restoredKey;

      keyWrapper(kek, key, wrappedKey);
      keyUnwrapper(kek, wrappedKey, restoredKey);

      return 0;
  }
#+end_src

#+RESULTS:
| Wrappedkey:  | 1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5 |
| IV:          | A6A6A6A6A6A6A6A6                                 |
| OriginalKey: | 00112233445566778899AABBCCDDEEFF                 |

*** Wrap
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var KEY = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  <<wrapper_functions>>

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> wrappedKey;

      keyWrapper(kek, key, wrappedKey);

      return 0;
  }
#+end_src

#+RESULTS:
: Wrappedkey: 1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5

*** Unwrap
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var WRAPPED_KEY = "1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  <<wrapper_functions>>

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> wrappedKey = hex_decode(WRAPPED_KEY);;
      vector<uint8_t> restoredKey;

      keyUnwrapper(kek, wrappedKey, restoredKey);

      return 0;
  }
#+end_src

#+RESULTS:
| IV:          | A6A6A6A6A6A6A6A6                 |
| OriginalKey: | 00112233445566778899AABBCCDDEEFF |

*** Wrap with IV
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var KEY = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var IV = "A6A6A6A6A6A6A6A6"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  <<wrapper_functions>>

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> iv = hex_decode(IV);
      vector<uint8_t> wrappedKey;

      keyWrapper(kek, key, wrappedKey, iv);

      return 0;
  }
#+end_src

#+RESULTS:
: Wrappedkey: 1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5

*** Unwrap with IV
#+HEADER: :var KEK = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var WRAPPED_KEY = "1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5"
#+HEADER: :var IV = "A6A6A6A6A6A6A6A6"
#+begin_src C++ :noweb yes
  #include <botan/block_cipher.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  <<wrapper_functions>>

  int main ()
  {
      vector<uint8_t> kek = hex_decode(KEK);
      vector<uint8_t> wrappedKey = hex_decode(WRAPPED_KEY);;
      vector<uint8_t> iv = hex_decode(IV);
      vector<uint8_t> restoredKey;

      keyUnwrapper(kek, wrappedKey, restoredKey, iv);

      return 0;
  }
#+end_src

#+RESULTS:
| IV:          | A6A6A6A6A6A6A6A6                 |
| OriginalKey: | 00112233445566778899AABBCCDDEEFF |
* ARIA
** ARIA-128
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> k = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-128"));

      cipher->set_key(k);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128 Encrypt: D718FBD6AB644C739DA95F3BE6451778

*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "D718FBD6AB644C739DA95F3BE6451778"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-128"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " Decrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128 Decrypt: 00112233445566778899AABBCCDDEEFF

** ARIA-192
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F0001020304050607"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-192"));

      cipher->set_key(key);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-192 Encrypt: 0DEDEC2A613869147C86397A97CA44F6

*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F0001020304050607"
#+HEADER: :var ENCRYPTED = "0DEDEC2A613869147C86397A97CA44F6"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-192"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-192 encrypt: 00112233445566778899AABBCCDDEEFF

** ARIA-256
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"
#+HEADER: :var TEXT = "00112233445566778899AABBCCDDEEFF"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(TEXT);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-256"));

      cipher->set_key(key);

      cipher->encrypt(block);
      cout << cipher->name() << " Encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-256 Encrypt: F92BD7C79FB72E2F2B8F80C1972D24FC
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"
#+HEADER: :var ENCRYPTED = "F92BD7C79FB72E2F2B8F80C1972D24FC"
#+begin_src C++
  #include <botan/block_cipher.h>
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> key = hex_decode(KEY);
      vector<uint8_t> block = hex_decode(ENCRYPTED);
      unique_ptr<BlockCipher> cipher(BlockCipher::create("ARIA-256"));

      cipher->set_key(key);

      cipher->decrypt(block);
      cout << cipher->name() << " encrypt: " << hex_encode(block) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-256 encrypt: 00112233445566778899AABBCCDDEEFF
** ARIA-GCM-128
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("ARIA-128/GCM", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_ad(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| ARIA-128/GCM(16) | Enc: | B2949DD080ADFFA66C72BE18A3817CF3 |
| ARIA-128/GCM(16) | Mac: | B7DFC8E22C8C3212AD7ACED059966E7A |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "B2949DD080ADFFA66C72BE18A3817CF3"
#+HEADER: :var INPUT_TAG = "B7DFC8E22C8C3212AD7ACED059966E7A"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("ARIA-128/GCM", DECRYPTION);

      dec->set_key(key);
      dec->set_ad(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
** ARIA-GCM-192
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF0011223344556677"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("ARIA-192/GCM", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_ad(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| ARIA-192/GCM(16) | Enc: | E203BFFE67525F15E258F465418F9378 |
| ARIA-192/GCM(16) | Mac: | 7AEBC287AE39724DB396BE4105808CD4 |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF0011223344556677"
#+HEADER: :var ENCRYPTED = "E203BFFE67525F15E258F465418F9378"
#+HEADER: :var INPUT_TAG = "7AEBC287AE39724DB396BE4105808CD4"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("ARIA-192/GCM", DECRYPTION);

      dec->set_key(key);
      dec->set_ad(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-192/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
** ARIA-GCM-256
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("ARIA-256/GCM", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->set_ad(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| ARIA-256/GCM(16) | Enc: | 5FD6F4743CC128D4692E467AC7082F48 |
| ARIA-256/GCM(16) | Mac: | 4A85EA53925DA74964CE1BE7F38A3840 |
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "5FD6F4743CC128D4692E467AC7082F48"
#+HEADER: :var INPUT_TAG = "4A85EA53925DA74964CE1BE7F38A3840"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("ARIA-256/GCM", DECRYPTION);

      dec->set_key(key);
      dec->set_ad(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-256/GCM(16) Dec: 102030405060708090A0B0C0D0E0F000
*** Encrypt text string
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "string text input"
#+HEADER: :var IV   = "112233445566778899AABBCC"
#+HEADER: :var AAD  = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const string input(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> enc = AEAD_Mode::create("ARIA-256/GCM", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.length());

      enc->set_key(key);
      enc->set_ad(aad);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      // cout << "ret : " << ret << endl;

      string enc_text = ret.substr(0, input.size()*2);
      string mac = ret.substr(input.size()*2, ret.length());
      cout << enc->name() <<  " Enc: " << enc_text << endl;
      cout << enc->name() <<  " Mac: " << mac << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| ARIA-256/GCM(16) | Enc: | 3C82B65D02C678209CF6829A7E86AF3D17 |
| ARIA-256/GCM(16) | Mac: | A75370B9E717F73875F02E4491FB022D   |
*** Decrypt to text string
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "3C82B65D02C678209CF6829A7E86AF3D17"
#+HEADER: :var INPUT_TAG = "A75370B9E717F73875F02E4491FB022D"
#+HEADER: :var IV        = "112233445566778899AABBCC"
#+HEADER: :var AAD       = "0102030405060708090A0B0C0D0E"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      vector<uint8_t> tag = hex_decode(INPUT_TAG);
      input.insert(input.end(), tag.begin(), tag.end());

      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> aad = hex_decode(AAD);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<AEAD_Mode> dec = AEAD_Mode::create("ARIA-256/GCM", DECRYPTION);

      dec->set_key(key);
      dec->set_ad(aad);
      dec->start(iv);
      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->finish(pt);

      std::string str(pt.begin(), pt.end());
      cout << dec->name() << " Dec: " << str << "\n";


      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-256/GCM(16) Dec: string text input
** ARIA-CBC-128
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cbc.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("ARIA-128/CBC/NoPadding", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128/CBC/NoPadding Enc: 57AC63C3A8F0121A4D54B0A8021EEBC9
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "57AC63C3A8F0121A4D54B0A8021EEBC9"
#+HEADER: :var IV        = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("ARIA-128/CBC/NoPadding", DECRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128/CBC/NoPadding Dec: 102030405060708090A0B0C0D0E0F000
** ARIA-CBC-128 PKCS7 Padding
*** Encrypt
#+HEADER: :var KEY  = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cbc.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("ARIA-128/CBC/PKCS7", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128/CBC/PKCS7 Enc: 57AC63C3A8F0121A4D54B0A8021EEBC9A1E16B15F52E223EBCBCB515A68E1342
*** Decrypt
#+HEADER: :var KEY       = "00112233445566778899AABBCCDDEEFF"
#+HEADER: :var ENCRYPTED = "57AC63C3A8F0121A4D54B0A8021EEBC9A1E16B15F52E223EBCBCB515A68E1342"
#+HEADER: :var IV        = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("ARIA-128/CBC/PKCS7", DECRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: ARIA-128/CBC/PKCS7 Dec: 102030405060708090A0B0C0D0E0F000
** ARIA-CTR-128
*** Encrypt
#+HEADER: :var KEY  = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var TEXT = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var IV   = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/cbc.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      const vector<uint8_t> input = hex_decode(TEXT);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> enc = Cipher_Mode::create("ARIA-128/CTR", ENCRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data()+input.size());

      enc->set_key(key);
      enc->start(iv);
      enc->finish(pt);

      string ret = hex_encode(pt);
      cout << enc->name() <<  " Enc: " << ret << endl;

      return 0;
  }
#+end_src

#+RESULTS:
: CTR-BE(ARIA-128) Enc: 787C57CE043D0BB74EAC829782E5563C
*** Decrypt
#+HEADER: :var KEY       = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var ENCRYPTED = "787C57CE043D0BB74EAC829782E5563C"
#+HEADER: :var IV        = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
#+begin_src C++
  #include <botan/gcm.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> input = hex_decode(ENCRYPTED);
      const vector<uint8_t> key = hex_decode(KEY);
      const vector<uint8_t> iv = hex_decode(IV);

      unique_ptr<Cipher_Mode> dec = Cipher_Mode::create("ARIA-128/CTR", DECRYPTION);

      secure_vector<uint8_t> pt(input.data(), input.data() + input.size());
      dec->set_key(key);
      dec->start(iv);
      dec->finish(pt);

      cout << dec->name() << " Dec: " << hex_encode(pt) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: CTR-BE(ARIA-128) Dec: 102030405060708090A0B0C0D0E0F000
* ECDH
** Random key - Create sessionkey
#+HEADER: :var TEXT        = "test msg"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdh.h>
  #include <botan/ec_group.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      AutoSeeded_RNG rng;
      // ec domain and
      EC_Group domain("secp256r1");
      // generate ECDH keys
      ECDH_PrivateKey keyA(rng, domain);
      ECDH_PrivateKey keyB(rng, domain);
      // Construct key agreements
      // string kdf = "KDF2(SHA-256)";
      // PK_Key_Agreement ecdhA(keyA,rng,kdf);
      // PK_Key_Agreement ecdhB(keyB,rng,kdf);
      PK_Key_Agreement ecdhA(keyA,rng,"Raw");
      PK_Key_Agreement ecdhB(keyB,rng,"Raw");

      BigInt bigA = keyA.private_value();
      cout << "private_keyA: " << bigA.to_hex_string() << endl;
      vector<uint8_t> pubkA = keyA.public_key_bits();
      cout << "public_keyA: " << hex_encode(pubkA) << endl;

      BigInt bigB = keyB.private_value();
      cout << "private_keyB: " << bigB.to_hex_string() << endl;
      vector<uint8_t> pubkB = keyB.public_key_bits();
      cout << "public_keyB: " << hex_encode(pubkB) << endl;


      // Agree on shared secret and derive symmetric key of 256 bit length
      secure_vector<uint8_t> sA = ecdhA.derive_key(32,keyB.public_value()).bits_of();
      secure_vector<uint8_t> sB = ecdhB.derive_key(32,keyA.public_value()).bits_of();

      if(sA != sB)
          return 1;

      cout << "agreed_key: " << hex_encode(sA) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_keyA: | 272381629D174EAD2F3939F2FFDCFCFDAFB5885E789EBA30969127F6B6E8F8E2                                                                   |
| public_keyA:  | 048D05F3D3FC92A06F97B3D6861D0C9425483E16E2F6AA2729F99211FF1B364E10A46B47A96EF995785245FC5302EF45A0D5EF1486B9865603969118D455AFBB53 |
| private_keyB: | EBF6E5A05A4AC0D1D2B2A629BF808B50B51DB7ED5E7CBAE968783C925FCC679D                                                                   |
| public_keyB:  | 04EFB6C4A48C69D85C6831922530536FE4500D16F90A454960465CDBF178E4728373D41625F3906A69107463FDD0FA03A1C4E1EB619968DEFEB41D1338B65049D4 |
| agreed_key:   | 3C027AF77D256133E465CE56ABC1CF31B3D428FD5FE528A4481BCF5D295DAA69                                                                   |

** Existing key(Hex) - Create sessionkey (Public key can be omitted)
#+HEADER: :var A_PRIVATE_KEY = "272381629D174EAD2F3939F2FFDCFCFDAFB5885E789EBA30969127F6B6E8F8E2"
#+HEADER: :var A_PUBLIC_KEY  = "048D05F3D3FC92A06F97B3D6861D0C9425483E16E2F6AA2729F99211FF1B364E10A46B47A96EF995785245FC5302EF45A0D5EF1486B9865603969118D455AFBB53"
#+HEADER: :var B_PRIVATE_KEY = "EBF6E5A05A4AC0D1D2B2A629BF808B50B51DB7ED5E7CBAE968783C925FCC679D"
#+HEADER: :var B_PUBLIC_KEY  = "04EFB6C4A48C69D85C6831922530536FE4500D16F90A454960465CDBF178E4728373D41625F3906A69107463FDD0FA03A1C4E1EB619968DEFEB41D1338B65049D4"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdh.h>
  #include <botan/ec_group.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      AutoSeeded_RNG rng;

      const vector<uint8_t> aPriKey = hex_decode(A_PRIVATE_KEY);
      const vector<uint8_t> bPriKey = hex_decode(B_PRIVATE_KEY);

      BigInt aPkey(aPriKey);
      BigInt bPkey(bPriKey);

      // ec domain and
      EC_Group domain("secp256r1");
      // generate ECDH keys
      ECDH_PrivateKey keyA(rng, domain, aPkey);
      ECDH_PrivateKey keyB(rng, domain, bPkey);

      ECDH_PublicKey keyApub(keyA);
      ECDH_PublicKey keyBpub(keyB);

      vector<uint8_t> pkA = keyApub.public_key_bits();
      if (A_PUBLIC_KEY != "" && hex_encode(pkA) != A_PUBLIC_KEY) {
          cout << "A : Invalid key pair." << endl;
          return 0;
      }

      vector<uint8_t> pkB = keyBpub.public_key_bits();
      if (B_PUBLIC_KEY != "" && hex_encode(pkB) != B_PUBLIC_KEY) {
          cout << "B : Invalid key pair." << endl;
          return 0;
      }

      // Construct key agreements
      // string kdf = "KDF2(SHA-256)";
      // PK_Key_Agreement ecdhA(keyA,rng,kdf);
      // PK_Key_Agreement ecdhB(keyB,rng,kdf);
      PK_Key_Agreement ecdhA(keyA,rng,"Raw");
      PK_Key_Agreement ecdhB(keyB,rng,"Raw");

      BigInt bigA = keyA.private_value();
      cout << "private_keyA: " << bigA.to_hex_string() << endl;
      vector<uint8_t> pubkA = keyA.public_key_bits();
      cout << "public_keyA: " << hex_encode(pubkA) << endl;

      BigInt bigB = keyB.private_value();
      cout << "private_keyB: " << bigB.to_hex_string() << endl;
      vector<uint8_t> pubkB = keyB.public_key_bits();
      cout << "public_keyB: " << hex_encode(pubkB) << endl;


      // Agree on shared secret and derive symmetric key of 256 bit length
      secure_vector<uint8_t> sA = ecdhA.derive_key(32,keyB.public_value()).bits_of();
      secure_vector<uint8_t> sB = ecdhB.derive_key(32,keyA.public_value()).bits_of();

      if(sA != sB)
          return 1;

      cout << "agreed_key: " << hex_encode(sA) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_keyA: | 272381629D174EAD2F3939F2FFDCFCFDAFB5885E789EBA30969127F6B6E8F8E2                                                                   |
| public_keyA:  | 048D05F3D3FC92A06F97B3D6861D0C9425483E16E2F6AA2729F99211FF1B364E10A46B47A96EF995785245FC5302EF45A0D5EF1486B9865603969118D455AFBB53 |
| private_keyB: | EBF6E5A05A4AC0D1D2B2A629BF808B50B51DB7ED5E7CBAE968783C925FCC679D                                                                   |
| public_keyB:  | 04EFB6C4A48C69D85C6831922530536FE4500D16F90A454960465CDBF178E4728373D41625F3906A69107463FDD0FA03A1C4E1EB619968DEFEB41D1338B65049D4 |
| agreed_key:   | 3C027AF77D256133E465CE56ABC1CF31B3D428FD5FE528A4481BCF5D295DAA69                                                                   |

** Existing key(Big Int) - Create sessionkey
#+HEADER: :var A_PRIVATE_KEY = "17702933725911759833018382133741290876335542967772335450363342488878254192866"
#+HEADER: :var A_PUBLIC_KEY  = "61017218725251769835925365666700278871445386965526678184487919969123210546842177730340048341794298839866705223449066751284256420111064842794150013009115987"
#+HEADER: :var B_PRIVATE_KEY = "106729748618016823529684004271423234939788438170848142794308826289302701631389"
#+HEADER: :var B_PUBLIC_KEY  = "66186069373064324507716733592744495348638623787425372736469519431587026981344737339468148830286137966427921162803027707669848205986009555327089307961805268"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdh.h>
  #include <botan/ec_group.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      AutoSeeded_RNG rng;

      BigInt aPkey(A_PRIVATE_KEY);
      BigInt bPkey(B_PRIVATE_KEY);

      // ec domain and
      EC_Group domain("secp256r1");
      // generate ECDH keys
      ECDH_PrivateKey keyA(rng, domain, aPkey);
      ECDH_PrivateKey keyB(rng, domain, bPkey);

      ECDH_PublicKey keyApub(keyA);
      ECDH_PublicKey keyBpub(keyB);

      vector<uint8_t> pkA = keyApub.public_key_bits();
      string strPkA(A_PUBLIC_KEY);
      if (A_PUBLIC_KEY != "" && BigInt(pkA) != BigInt(strPkA)) {
          cout << "A : Invalid key pair." << endl;
          return 0;
      }

      vector<uint8_t> pkB = keyBpub.public_key_bits();
      string strPkB(B_PUBLIC_KEY);
      if (B_PUBLIC_KEY != "" && BigInt(pkB) != BigInt(strPkB)) {
          cout << "B : Invalid key pair." << endl;
          return 0;
      }

      // Construct key agreements
      // string kdf = "KDF2(SHA-256)";
      // PK_Key_Agreement ecdhA(keyA,rng,kdf);
      // PK_Key_Agreement ecdhB(keyB,rng,kdf);
      PK_Key_Agreement ecdhA(keyA,rng,"Raw");
      PK_Key_Agreement ecdhB(keyB,rng,"Raw");

      BigInt bigA = keyA.private_value();
      cout << "private_keyA: " << bigA.to_hex_string() << endl;
      vector<uint8_t> pubkA = keyA.public_key_bits();
      cout << "public_keyA: " << hex_encode(pubkA) << endl;

      BigInt bigB = keyB.private_value();
      cout << "private_keyB: " << bigB.to_hex_string() << endl;
      vector<uint8_t> pubkB = keyB.public_key_bits();
      cout << "public_keyB: " << hex_encode(pubkB) << endl;


      // Agree on shared secret and derive symmetric key of 256 bit length
      secure_vector<uint8_t> sA = ecdhA.derive_key(32,keyB.public_value()).bits_of();
      secure_vector<uint8_t> sB = ecdhB.derive_key(32,keyA.public_value()).bits_of();

      if(sA != sB)
          return 1;

      cout << "agreed_key(Hex): " << hex_encode(sA) << endl;
      cout << "agreed_key(BigInt): " << BigInt(sA).to_dec_string() << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_keyA:       | 272381629D174EAD2F3939F2FFDCFCFDAFB5885E789EBA30969127F6B6E8F8E2                                                                   |
| public_keyA:        | 048D05F3D3FC92A06F97B3D6861D0C9425483E16E2F6AA2729F99211FF1B364E10A46B47A96EF995785245FC5302EF45A0D5EF1486B9865603969118D455AFBB53 |
| private_keyB:       | EBF6E5A05A4AC0D1D2B2A629BF808B50B51DB7ED5E7CBAE968783C925FCC679D                                                                   |
| public_keyB:        | 04EFB6C4A48C69D85C6831922530536FE4500D16F90A454960465CDBF178E4728373D41625F3906A69107463FDD0FA03A1C4E1EB619968DEFEB41D1338B65049D4 |
| agreed_key(Hex):    | 3C027AF77D256133E465CE56ABC1CF31B3D428FD5FE528A4481BCF5D295DAA69                                                                   |
| agreed_key(BigInt): | 27143153294466088880496358460888297068895292863519913920482132860624216894057                                                      |

** Existing key(Hex) - Create sessionkey with PriKey A, PubKey B
#+HEADER: :var A_PRIVATE_KEY = "272381629D174EAD2F3939F2FFDCFCFDAFB5885E789EBA30969127F6B6E8F8E2"
#+HEADER: :var B_PUBLIC_KEY  = "EFB6C4A48C69D85C6831922530536FE4500D16F90A454960465CDBF178E4728373D41625F3906A69107463FDD0FA03A1C4E1EB619968DEFEB41D1338B65049D4"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdh.h>
  #include <botan/ec_group.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      AutoSeeded_RNG rng;

      const vector<uint8_t> aPriKey = hex_decode(A_PRIVATE_KEY);
      vector<uint8_t> bPubKey = hex_decode(B_PUBLIC_KEY);
      bPubKey.insert(bPubKey.begin(), 4);

      BigInt aPkey(aPriKey);

      // ec domain and
      EC_Group domain("secp256r1");
      // generate ECDH keys
      ECDH_PrivateKey keyA(rng, domain, aPkey);

      ECDH_PublicKey keyApub(keyA);

      // Construct key agreements
      // string kdf = "KDF2(SHA-256)";
      // PK_Key_Agreement ecdhA(keyA,rng,kdf);
      // PK_Key_Agreement ecdhB(keyB,rng,kdf);
      PK_Key_Agreement ecdhA(keyA,rng,"Raw");

      BigInt bigA = keyA.private_value();
      cout << "private_keyA: " << bigA.to_hex_string() << endl;
      vector<uint8_t> pubkA = keyA.public_key_bits();
      cout << "public_keyA: " << hex_encode(pubkA) << endl;

      // Agree on shared secret and derive symmetric key of 256 bit length
      secure_vector<uint8_t> sA = ecdhA.derive_key(32,bPubKey).bits_of();

      cout << "agreed_key: " << hex_encode(sA) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_keyA: | 272381629D174EAD2F3939F2FFDCFCFDAFB5885E789EBA30969127F6B6E8F8E2                                                                   |
| public_keyA:  | 048D05F3D3FC92A06F97B3D6861D0C9425483E16E2F6AA2729F99211FF1B364E10A46B47A96EF995785245FC5302EF45A0D5EF1486B9865603969118D455AFBB53 |
| agreed_key:   | 3C027AF77D256133E465CE56ABC1CF31B3D428FD5FE528A4481BCF5D295DAA69                                                                   |

* ECDSA
** Demo
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/ec_group.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      std::string text("testmsg");
      std::vector<uint8_t> data(text.data(),text.data()+text.length());

      Botan::AutoSeeded_RNG rng;

      // Generate ECDSA keypair
      Botan::ECDSA_PrivateKey prikey(rng, Botan::EC_Group("secp256r1"));
      Botan::ECDSA_PublicKey pubkey(prikey);

      BigInt bgprikey = prikey.private_value();
      cout << "prikey: " << bgprikey.to_hex_string() << endl;

      // Public key generated from private key
      vector<uint8_t> pubk = pubkey.public_key_bits();
      cout << "pubkey1: " << hex_encode(pubk) << endl;

      // Pubic key value from private key
      vector<uint8_t> pubk2 = prikey.public_key_bits() ;
      cout << "pubkey2: " << hex_encode(pubk2) << endl;

      // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;

      // verify signature
      Botan::PK_Verifier verifier(pubkey, "EMSA1(SHA-256)");
      verifier.update(data);
      std::cout << "signature " << (verifier.check_signature(signature)? "valid" : "invalid");

      return 0;
  }
#+end_src

#+RESULTS:
| prikey:    | 6BBAB443BF3ED32282068E803D7F7F5FBC686C5032953F9B5BA0E610A7B82AAE                                                                   |
| pubkey1:   | 0480AE09B3BE4CF77E50B2B03DECE1FAAF763E431F8FE718D5E642F747D96BB52B702C98A99AA66DC6528B5B2E4BA3008DB6C062CCA03577C48D2D3686E78D536B |
| pubkey2:   | 0480AE09B3BE4CF77E50B2B03DECE1FAAF763E431F8FE718D5E642F747D96BB52B702C98A99AA66DC6528B5B2E4BA3008DB6C062CCA03577C48D2D3686E78D536B |
| Signature: | AFB70D8B741F7D44610C17C85612EE1990AFC7EE0E6D056E5F88E4FE18C922DF29E0825C1E7B60B451C519B92EFE7E1B8E1DD4A1D222165DBC74D05CD06B77D1   |
| signature  | valid                                                                                                                              |

** Random key - Create signature - TEXT input
#+HEADER: :var TEXT        = "test msg"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      Botan::AutoSeeded_RNG rng;

      // Generate ECDSA keypair
      Botan::ECDSA_PrivateKey prikey(rng, Botan::EC_Group("secp256r1"));
      Botan::ECDSA_PublicKey pubkey(prikey);

      BigInt bgprikey = prikey.private_value();
      cout << "private_key: " << bgprikey.to_hex_string() << endl;

      // Public key generated from private key
      vector<uint8_t> pubk = pubkey.public_key_bits();
      cout << "public_key: " << hex_encode(pubk) << endl;

      std::string text(TEXT);
      std::vector<uint8_t> data(text.data(),text.data()+text.length());

      // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_key: | DBC868EF66949314FC040180FC6F1A9867466028364140361FF770733B23EF76                                                                   |
| public_key:  | 04A9A712C7B56F3C878F230C6F6F31564D11D29F9E30A146E7F99904F6FD743708662C3B989201E6437F9DC261AF500F68C93EF2382F93F9B842E679F5297C1907 |
| Signature:   | 631A5DBE42230344B4AD5F0B53B0B6661970AD403CAF09BD56BEB8D9E24EAF8258761C4EBE258CE8B182DC6B28F540C05D72FFA909A09AC0166A2AAB1C85C238   |

** Random key - Create signature - HEX input
#+HEADER: :var TEXT        = "010203040506"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      Botan::AutoSeeded_RNG rng;

      // Generate ECDSA keypair
      Botan::ECDSA_PrivateKey prikey(rng, Botan::EC_Group("secp256r1"));
      Botan::ECDSA_PublicKey pubkey(prikey);
      std::vector<uint8_t> data = hex_decode(TEXT);

      BigInt bgprikey = prikey.private_value();
      cout << "private_key: " << bgprikey.to_hex_string() << endl;

      // Public key generated from private key
      vector<uint8_t> pubk = pubkey.public_key_bits();
      cout << "public_key: " << hex_encode(pubk) << endl;


      // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;

      return 0;
  }
#+end_src

#+RESULTS:
| private_key: | 20EA2E851163D5DCA706FB775EC3A374C089153D4D1715FA77E360B029D6CF3F                                                                   |
| public_key:  | 04C5753966CF021EBF8A58B044C1122D40665728DE3AB709C340A69F5526D9DD9A10A4EA3DD751145AB015B8593666B30A33FBB8F7303C24FF357C33A6E9518D82 |
| Signature:   | 7DEA65D1F0D03C379D7457441CDA5125380486DF74B8BE3CFBE258D9E61CB790F55C3ED4CC4720E62A5F7B5119A47421D01A05FF478875641EE369D021E42E61   |

** Existing key - Create signature TEXT input
#+HEADER: :var TEXT        = "test msg"
#+HEADER: :var PRIVATE_KEY = "DBC868EF66949314FC040180FC6F1A9867466028364140361FF770733B23EF76"
#+HEADER: :var PUBLIC_KEY  = "04A9A712C7B56F3C878F230C6F6F31564D11D29F9E30A146E7F99904F6FD743708662C3B989201E6437F9DC261AF500F68C93EF2382F93F9B842E679F5297C1907"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      Botan::AutoSeeded_RNG rng;
  
      const vector<uint8_t> private_key = hex_decode(PRIVATE_KEY);
      const vector<uint8_t> public_key = hex_decode(PUBLIC_KEY);
  
      BigInt bprikey(private_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bprikey);
      ECDSA_PublicKey pubkey(prikey);
  
      vector<uint8_t> pubk = pubkey.public_key_bits() ;
      if (hex_encode(pubk) != PUBLIC_KEY) {
          cout << "Invalid key pair." << endl;
          return 0;
      }
  
      std::string text(TEXT);
      std::vector<uint8_t> data(text.data(),text.data()+text.length());
  
      // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature: AC2527E96694CC18BD9A89D1F101CEC292887BC79EE1BD5D9E20CC0E67DFB26C5E486FE5535811368C7D88490399C91D478321A04F05E9C9E265EC1416A41185

** Existing key - Create signature HEX input
#+HEADER: :var TEXT        = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var PRIVATE_KEY = "DBC868EF66949314FC040180FC6F1A9867466028364140361FF770733B23EF76"
#+HEADER: :var PUBLIC_KEY  = "04A9A712C7B56F3C878F230C6F6F31564D11D29F9E30A146E7F99904F6FD743708662C3B989201E6437F9DC261AF500F68C93EF2382F93F9B842E679F5297C1907"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      Botan::AutoSeeded_RNG rng;
  
      const vector<uint8_t> private_key = hex_decode(PRIVATE_KEY);
      const vector<uint8_t> public_key = hex_decode(PUBLIC_KEY);
      std::vector<uint8_t> data = hex_decode(TEXT);
  
      BigInt bprikey(private_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bprikey);
      ECDSA_PublicKey pubkey(prikey);
  
      vector<uint8_t> pubk = pubkey.public_key_bits() ;
      if (hex_encode(pubk) != PUBLIC_KEY) {
          cout << "Invalid key pair." << endl;
          return 0;
      }
  
      // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature: 999ED1ADF893B7E4812D43AF1205FCAC40B55FAEA44EEAF0B040F4596D7DA0AD3767A2381D288EFB5F2B7684F9A385710653B2C1E094B9C9DEF8A3898F734C78

** Existing key - Create signature HEX input with only private key
#+HEADER: :var TEXT        = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var PRIVATE_KEY = "DBC868EF66949314FC040180FC6F1A9867466028364140361FF770733B23EF76"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      Botan::AutoSeeded_RNG rng;
  
      const vector<uint8_t> private_key = hex_decode(PRIVATE_KEY);
      std::vector<uint8_t> data = hex_decode(TEXT);
  
      BigInt bprikey(private_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bprikey);
      // ECDSA_PublicKey pubkey(prikey);
  
      // // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature: D86EE38D4A45145A6083382EB61245F10A5A3F144746EAA2612BF6C6743A01F553D0C9EB9B3F484901F15FD59116A0F23F2FAC5F3954C11FFAA9E6454E6E0BFF

** Existing key - Signature check - TEXT input
#+HEADER: :var TEXT        = "test msg"
#+HEADER: :var PRIVATE_KEY = "DBC868EF66949314FC040180FC6F1A9867466028364140361FF770733B23EF76"
#+HEADER: :var PUBLIC_KEY  = "04A9A712C7B56F3C878F230C6F6F31564D11D29F9E30A146E7F99904F6FD743708662C3B989201E6437F9DC261AF500F68C93EF2382F93F9B842E679F5297C1907"
#+HEADER: :var SIGNATURE   = "AC2527E96694CC18BD9A89D1F101CEC292887BC79EE1BD5D9E20CC0E67DFB26C5E486FE5535811368C7D88490399C91D478321A04F05E9C9E265EC1416A41185"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      Botan::AutoSeeded_RNG rng;

      const vector<uint8_t> private_key = hex_decode(PRIVATE_KEY);
      const vector<uint8_t> public_key = hex_decode(PUBLIC_KEY);

      BigInt bprikey(private_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bprikey);
      ECDSA_PublicKey pubkey(prikey);

      vector<uint8_t> pubk = pubkey.public_key_bits() ;
      if (hex_encode(pubk) != PUBLIC_KEY) {
          cout << "Invalid key pair." << endl;
          return 0;
      }

      std::string text(TEXT);
      std::vector<uint8_t> data(text.data(),text.data()+text.length());

      // verify signature
      Botan::PK_Verifier verifier(pubkey, "EMSA1(SHA-256)");
      verifier.update(data);
      std::cout << "Signature " << (verifier.check_signature(hex_decode(SIGNATURE))? "valid" : "invalid");

      return 0;
  }
#+end_src

#+RESULTS:
: Signature valid
** Existing key - Signature check - HEX input
#+HEADER: :var TEXT        = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var PRIVATE_KEY = "DBC868EF66949314FC040180FC6F1A9867466028364140361FF770733B23EF76"
#+HEADER: :var PUBLIC_KEY  = "04A9A712C7B56F3C878F230C6F6F31564D11D29F9E30A146E7F99904F6FD743708662C3B989201E6437F9DC261AF500F68C93EF2382F93F9B842E679F5297C1907"
#+HEADER: :var SIGNATURE   = "999ED1ADF893B7E4812D43AF1205FCAC40B55FAEA44EEAF0B040F4596D7DA0AD3767A2381D288EFB5F2B7684F9A385710653B2C1E094B9C9DEF8A3898F734C78"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main()
  {
      Botan::AutoSeeded_RNG rng;

      const vector<uint8_t> private_key = hex_decode(PRIVATE_KEY);
      const vector<uint8_t> public_key = hex_decode(PUBLIC_KEY);
      std::vector<uint8_t> data = hex_decode(TEXT);

      BigInt bprikey(private_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bprikey);
      ECDSA_PublicKey pubkey(prikey);

      vector<uint8_t> pubk = pubkey.public_key_bits() ;
      if (hex_encode(pubk) != PUBLIC_KEY) {
          cout << "Invalid key pair." << endl;
          return 0;
      }

      // verify signature
      Botan::PK_Verifier verifier(pubkey, "EMSA1(SHA-256)");
      verifier.update(data);
      std::cout << "Signature " << (verifier.check_signature(hex_decode(SIGNATURE))? "valid" : "invalid");

      return 0;
  }
#+end_src

#+RESULTS:
: Signature valid
** Existing key - Signature check - HEX input with only Public key
#+HEADER: :var TEXT        = "000102030405060708090A0B0C0D0E0F000102030405060708090A0B0C0D0E0F"
#+HEADER: :var PUBLIC_KEY  = "04A9A712C7B56F3C878F230C6F6F31564D11D29F9E30A146E7F99904F6FD743708662C3B989201E6437F9DC261AF500F68C93EF2382F93F9B842E679F5297C1907"
#+HEADER: :var SIGNATURE   = "999ED1ADF893B7E4812D43AF1205FCAC40B55FAEA44EEAF0B040F4596D7DA0AD3767A2381D288EFB5F2B7684F9A385710653B2C1E094B9C9DEF8A3898F734C78"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/ecdsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      Botan::AutoSeeded_RNG rng;
  
      const vector<uint8_t> public_key = hex_decode(PUBLIC_KEY);
      std::vector<uint8_t> data = hex_decode(TEXT);
      std::vector<uint8_t> sig = hex_decode(SIGNATURE);
  
      BigInt bpubkey(public_key);
      ECDSA_PrivateKey prikey(rng, EC_Group("secp256r1"), bpubkey);
      ECDSA_PublicKey pubkey(prikey.algorithm_identifier(), public_key);
  
      // verify signature
      Botan::PK_Verifier verifier(pubkey, "EMSA1(SHA-256)");
      verifier.update(data);
      std::cout << "Signature " << (verifier.check_signature(sig)? "valid" : "invalid");
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature valid
* PBKDF2
** PBKDF2 - Text passphrase
#+HEADER: :var PASSPHRASE = "abcd"
#+HEADER: :var SALT       = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var ITERATION  = 1001
#+HEADER: :var KEY_LEN    = 32
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <botan/pbkdf2.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> salt1 = hex_decode(SALT);
      uint8_t salt[256] = {0,};
      int salt_len = salt1.size();
      copy(salt1.begin(), salt1.end(), salt);

      // For example "PBKDF2(SHA-256)", "Scrypt", "OpenPGP-S2K(SHA-384)". Returns null if not available.
      unique_ptr<PBKDF> kdf = PBKDF::create("PBKDF2(SHA-256)");
      secure_vector<uint8_t> dk = kdf->pbkdf_iterations(KEY_LEN, PASSPHRASE, salt, salt_len, ITERATION);

      cout << "Derived key: " << hex_encode(dk) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: Derived key: DECF9EF197B87ABBDB6CBA9E81A7BCB8AC36BB2BFA3B93746C8042227A27CFEA

** PBKDF2 - HEX passphrase
#+HEADER: :var PASSPHRASE = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var SALT       = "102030405060708090A0B0C0D0E0F000"
#+HEADER: :var ITERATION  = 1001
#+HEADER: :var KEY_LEN    = 32
#+begin_src C++
  #include <botan/hash.h>
  #include <botan/hex.h>
  #include <botan/pbkdf2.h>
  #include <iostream>

  using namespace std;
  using namespace Botan;

  int main ()
  {
      vector<uint8_t> salt1 = hex_decode(SALT);
      uint8_t salt[256] = {0,};
      int salt_len = salt1.size();
      copy(salt1.begin(), salt1.end(), salt);
      vector<uint8_t> pass1 = hex_decode(PASSPHRASE);
      string pass(pass1.begin(), pass1.end());

      // For example "PBKDF2(SHA-256)", "Scrypt", "OpenPGP-S2K(SHA-384)". Returns null if not available.
      unique_ptr<PBKDF> kdf = PBKDF::create("PBKDF2(SHA-256)");
      secure_vector<uint8_t> dk = kdf->pbkdf_iterations(KEY_LEN, pass, salt, salt_len, ITERATION);

      cout << "Derived key: " << hex_encode(dk) << "\n";

      return 0;
  }
#+end_src

#+RESULTS:
: Derived key: 9CA9E2C9F93EA70B744F9F751637B6C4EA7841F27BFF884902BF5CB48690F229

* RSA
** Demo
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/rsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      std::string text("testmsg");
      std::vector<uint8_t> data(text.data(),text.data()+text.length());
  
      Botan::AutoSeeded_RNG rng;
  
      // Generate RSA keypair
      Botan::RSA_PrivateKey prikey(rng, 2048);
      Botan::RSA_PublicKey pubkey(prikey);
  
      secure_vector<uint8_t> prik = prikey.private_key_bits();
      cout << "prikey: " << hex_encode(prik) << endl;
      BigInt pric = prikey.get_c();
      BigInt prid = prikey.get_d();
      BigInt prid1 = prikey.get_d1();
      BigInt prid2 = prikey.get_d2();
      BigInt prie = prikey.get_e();
      BigInt prin = prikey.get_n();
      BigInt prip = prikey.get_p();
      BigInt priq = prikey.get_q();
      cout << "prikey_c: " << pric.to_hex_string() << endl;
      cout << "prikey_d: " << prid.to_hex_string() << endl;
      cout << "prikey_d1: " << prid1.to_hex_string() << endl;
      cout << "prikey_d2: " << prid2.to_hex_string() << endl;
      cout << "prikey_e: " << prie.to_hex_string() << endl;
      cout << "prikey_n: " << prin.to_hex_string() << endl;
      cout << "prikey_p: " << prip.to_hex_string() << endl;
      cout << "prikey_q: " << priq.to_hex_string() << endl;
  
      // // Public key generated from private key
      vector<uint8_t> pubk = pubkey.public_key_bits();
      cout << "pubkey1: " << hex_encode(pubk) << endl;
  
      // // Pubic key value from private key
      vector<uint8_t> pubk2 = prikey.public_key_bits() ;
      cout << "pubkey2: " << hex_encode(pubk2) << endl;
  
      BigInt pube = pubkey.get_e();
      BigInt pubn = pubkey.get_n();
      cout << "pubkey_e: " << pube.to_hex_string() << endl;
      cout << "pubkey_n: " << pubn.to_hex_string() << endl;
  
      // // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(data);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;
  
      // // verify signature
      Botan::PK_Verifier verifier(pubkey, "EMSA1(SHA-256)");
      verifier.update(data);
      std::cout << "signature " << (verifier.check_signature(signature)? "valid" : "invalid");
  
      return 0;
  }
#+end_src

#+RESULTS:
| prikey:    | 308204A30201000282010100BECD09417771C1688F0FC4211DF3AFF5C615C2FFD47BDC25671D84A0BFC0A4DD151BA8F2D3416E336D3AA32F02952D06F102E04C4246CE76E0CBF9AA5433C82076FD7E900D8BF2F6255FD1539ECD7821DBE4976E91A316B4DC27FFA3F20C3270E6CB82F838404FD86A393A998D44BDDB1A03BB1960649E9E555949E1ADDAB3CC2216356B9DE4225E37F8D1471FD70134352E1509AEB7C4EE3FF9AE747ECB3BD2A5D11AAA67ADBCB4A08E3490F99C98AB06D961FBE219D1DD55B0A8F32A0E510DDCCC648D4F95D3FB6251248FA2D6F89748B4CC1AB06A76781EF03B9AB559FBA3E4B0C5C853FB349D5C7FBA8F54D05CD76D56BB22F4326F316E1AC49BDE87B2ED0203010001028201000A5E376ACA8C10ABB71C6EF6B2BB377C56417FF969693A9F00B1B2AF8E83F021806062A7A151ACA49842A7B3EA02C3B1DD1E60245CB49ECB086FA5173BA09DB71FE829FCB773BBA5E30588293057AF77BD8C782B1EB85B4744305B3CA42E43FE6D18317B7E09069DB6B5F9E876ABFDDA1E59860CFCB733045D146F46976D2B386C374C4AFF1CF0A41C20BABC6B558925AFEEC14206576DD43AADA6EDD454D8F9EC88283B9659501C319E73BE681EC14968096895C154FC405ED93F94BCC704EF4092DEFA957A6013F87EC6452C1BD8213014E090953FC52E2ECA0C26A4A3920FE0A179B5144A1F85C1AB29B9557CA31C53AA02E982938AC3A7A6F963FCB3FAF902818100E59E29CDC32B5186392D4A2339FBCBD47049D3A1BA3E2EE35361D8B0AECE2ACB7250F6B9454AF59F4346E669D07CAD1D77E80B2C7767B5324EA1C30390D928745A79AEAE50094CD337A45C68A3FAA46ACEFE842C99B7AD8A81990F6CD5A60D09B81C4BEF45A4A197F557F83C3806CC9B3B38454B6EAA65EEFDA2BF76CE58555502818100D4B922F0A78FFC21FFD9525481464CE1E498D5A6053A39AD5D91975EC27188A9360BEFFCCF4B4ACFDF052E5AA3D6A87DA16E31C2805EA5CC803191D981092F8D8EC014595971A394998A2B0D4061ED7BE0047B2FD2A24AD8725AD3353D3A49D3F0104160DD5EBA9101F27B6DAD3DF9555A8C424C83DB37EAA7EB31CE5869E7390281800590538AFCD3ABE208B8A4373E4C6F9FF22897CC2F6B1A4FBFD17B22ACD9AA07CBF952412300B1FAEDF265DAE28662DB77F05374FC5FB2F0491F7A4E37D04B3EA682944CFCFB7CB51180160D230C0BB7DAD427F7BCB1CAAEB47D34F67A26CFE21067FF1F091CF81D6A807B2F5A5C2FD1031A55F381F6F7095773FE17AEE04D110281805448F2C625AE50396C754040C964006C74B5F5D92D330FCD5848AA905A3CBFE843C8E112EB53AAD5C848F63FE5B0D4DBCA4DAE1BA1DF5E9433AAF05E1CD975E501CDAB826785364A57B7BE2D26F8662F71E874A2D33388B250451A707ACD10999001F0D59F80BC2D5E77245EA588EBB4DD06BBF2334075DC5D223C7EC4DB594902818100804F41182E6085F28B70228DE9759FC809945412434C1CF4478C0EC5659D7FB590DBCEE64DEA14C8E5F66E6CF2A766AFF92316BEB7629622C1C45B3B4C62AE88EB921905BDFD44077600566F637BA3DD8BBA864338C276ACA80D25FA93FCD376660A2AC99B1C771AF3814D982FFB2A994FB029E19939DE92E141EF877620968C |
| prikey_c:  | 804F41182E6085F28B70228DE9759FC809945412434C1CF4478C0EC5659D7FB590DBCEE64DEA14C8E5F66E6CF2A766AFF92316BEB7629622C1C45B3B4C62AE88EB921905BDFD44077600566F637BA3DD8BBA864338C276ACA80D25FA93FCD376660A2AC99B1C771AF3814D982FFB2A994FB029E19939DE92E141EF877620968C                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| prikey_d:  | 0A5E376ACA8C10ABB71C6EF6B2BB377C56417FF969693A9F00B1B2AF8E83F021806062A7A151ACA49842A7B3EA02C3B1DD1E60245CB49ECB086FA5173BA09DB71FE829FCB773BBA5E30588293057AF77BD8C782B1EB85B4744305B3CA42E43FE6D18317B7E09069DB6B5F9E876ABFDDA1E59860CFCB733045D146F46976D2B386C374C4AFF1CF0A41C20BABC6B558925AFEEC14206576DD43AADA6EDD454D8F9EC88283B9659501C319E73BE681EC14968096895C154FC405ED93F94BCC704EF4092DEFA957A6013F87EC6452C1BD8213014E090953FC52E2ECA0C26A4A3920FE0A179B5144A1F85C1AB29B9557CA31C53AA02E982938AC3A7A6F963FCB3FAF9                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| prikey_d1: | 0590538AFCD3ABE208B8A4373E4C6F9FF22897CC2F6B1A4FBFD17B22ACD9AA07CBF952412300B1FAEDF265DAE28662DB77F05374FC5FB2F0491F7A4E37D04B3EA682944CFCFB7CB51180160D230C0BB7DAD427F7BCB1CAAEB47D34F67A26CFE21067FF1F091CF81D6A807B2F5A5C2FD1031A55F381F6F7095773FE17AEE04D11                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| prikey_d2: | 5448F2C625AE50396C754040C964006C74B5F5D92D330FCD5848AA905A3CBFE843C8E112EB53AAD5C848F63FE5B0D4DBCA4DAE1BA1DF5E9433AAF05E1CD975E501CDAB826785364A57B7BE2D26F8662F71E874A2D33388B250451A707ACD10999001F0D59F80BC2D5E77245EA588EBB4DD06BBF2334075DC5D223C7EC4DB5949                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| prikey_e:  | 10001                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| prikey_n:  | BECD09417771C1688F0FC4211DF3AFF5C615C2FFD47BDC25671D84A0BFC0A4DD151BA8F2D3416E336D3AA32F02952D06F102E04C4246CE76E0CBF9AA5433C82076FD7E900D8BF2F6255FD1539ECD7821DBE4976E91A316B4DC27FFA3F20C3270E6CB82F838404FD86A393A998D44BDDB1A03BB1960649E9E555949E1ADDAB3CC2216356B9DE4225E37F8D1471FD70134352E1509AEB7C4EE3FF9AE747ECB3BD2A5D11AAA67ADBCB4A08E3490F99C98AB06D961FBE219D1DD55B0A8F32A0E510DDCCC648D4F95D3FB6251248FA2D6F89748B4CC1AB06A76781EF03B9AB559FBA3E4B0C5C853FB349D5C7FBA8F54D05CD76D56BB22F4326F316E1AC49BDE87B2ED                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| prikey_p:  | E59E29CDC32B5186392D4A2339FBCBD47049D3A1BA3E2EE35361D8B0AECE2ACB7250F6B9454AF59F4346E669D07CAD1D77E80B2C7767B5324EA1C30390D928745A79AEAE50094CD337A45C68A3FAA46ACEFE842C99B7AD8A81990F6CD5A60D09B81C4BEF45A4A197F557F83C3806CC9B3B38454B6EAA65EEFDA2BF76CE585555                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| prikey_q:  | D4B922F0A78FFC21FFD9525481464CE1E498D5A6053A39AD5D91975EC27188A9360BEFFCCF4B4ACFDF052E5AA3D6A87DA16E31C2805EA5CC803191D981092F8D8EC014595971A394998A2B0D4061ED7BE0047B2FD2A24AD8725AD3353D3A49D3F0104160DD5EBA9101F27B6DAD3DF9555A8C424C83DB37EAA7EB31CE5869E739                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| pubkey1:   | 3082010A0282010100BECD09417771C1688F0FC4211DF3AFF5C615C2FFD47BDC25671D84A0BFC0A4DD151BA8F2D3416E336D3AA32F02952D06F102E04C4246CE76E0CBF9AA5433C82076FD7E900D8BF2F6255FD1539ECD7821DBE4976E91A316B4DC27FFA3F20C3270E6CB82F838404FD86A393A998D44BDDB1A03BB1960649E9E555949E1ADDAB3CC2216356B9DE4225E37F8D1471FD70134352E1509AEB7C4EE3FF9AE747ECB3BD2A5D11AAA67ADBCB4A08E3490F99C98AB06D961FBE219D1DD55B0A8F32A0E510DDCCC648D4F95D3FB6251248FA2D6F89748B4CC1AB06A76781EF03B9AB559FBA3E4B0C5C853FB349D5C7FBA8F54D05CD76D56BB22F4326F316E1AC49BDE87B2ED0203010001                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| pubkey2:   | 3082010A0282010100BECD09417771C1688F0FC4211DF3AFF5C615C2FFD47BDC25671D84A0BFC0A4DD151BA8F2D3416E336D3AA32F02952D06F102E04C4246CE76E0CBF9AA5433C82076FD7E900D8BF2F6255FD1539ECD7821DBE4976E91A316B4DC27FFA3F20C3270E6CB82F838404FD86A393A998D44BDDB1A03BB1960649E9E555949E1ADDAB3CC2216356B9DE4225E37F8D1471FD70134352E1509AEB7C4EE3FF9AE747ECB3BD2A5D11AAA67ADBCB4A08E3490F99C98AB06D961FBE219D1DD55B0A8F32A0E510DDCCC648D4F95D3FB6251248FA2D6F89748B4CC1AB06A76781EF03B9AB559FBA3E4B0C5C853FB349D5C7FBA8F54D05CD76D56BB22F4326F316E1AC49BDE87B2ED0203010001                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| pubkey_e:  | 10001                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| pubkey_n:  | BECD09417771C1688F0FC4211DF3AFF5C615C2FFD47BDC25671D84A0BFC0A4DD151BA8F2D3416E336D3AA32F02952D06F102E04C4246CE76E0CBF9AA5433C82076FD7E900D8BF2F6255FD1539ECD7821DBE4976E91A316B4DC27FFA3F20C3270E6CB82F838404FD86A393A998D44BDDB1A03BB1960649E9E555949E1ADDAB3CC2216356B9DE4225E37F8D1471FD70134352E1509AEB7C4EE3FF9AE747ECB3BD2A5D11AAA67ADBCB4A08E3490F99C98AB06D961FBE219D1DD55B0A8F32A0E510DDCCC648D4F95D3FB6251248FA2D6F89748B4CC1AB06A76781EF03B9AB559FBA3E4B0C5C853FB349D5C7FBA8F54D05CD76D56BB22F4326F316E1AC49BDE87B2ED                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Signature: | B27148E1CCC7CA851AF31C3BC1D439076EE914EC1497ED42BA58FD16481420A9DD5C0C1A4F796AA104084FB59080D39B00FAE2B6968E0420BD5FBAF843D5B43BF4AF5C1C91EBEF788B78EF15C5192EEC7A9F6A70FEF48D8E3DE0476B91F0CAD421DAB810964634414F7C8D1E5D18BB03CE4C54BF20B39137116CFDAFCB1676D761B9C1F10CE3994CB520854A55757C4F53FA7789481D8B564C52B0FD4882C7188DEE7D7883DEFC03E97BFD071E06D5308D8C437EE89626AC7F22CE899F995EA6E7C8C485F199107BCC591FE593258CD5802D5D2A647A3C500B69D78F96D4D5E62F04166E49F8ED718091D05358D88252FDFD0F9AA1D27FF78716A78B7FA5ECD8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| signature  | valid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |

** Encrypt
#+HEADER: :var HEX_M = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var VAL_E = "010001"
#+HEADER: :var VAL_P = "E59E29CDC32B5186392D4A2339FBCBD47049D3A1BA3E2EE35361D8B0AECE2ACB7250F6B9454AF59F4346E669D07CAD1D77E80B2C7767B5324EA1C30390D928745A79AEAE50094CD337A45C68A3FAA46ACEFE842C99B7AD8A81990F6CD5A60D09B81C4BEF45A4A197F557F83C3806CC9B3B38454B6EAA65EEFDA2BF76CE585555"
#+HEADER: :var VAL_Q = "D4B922F0A78FFC21FFD9525481464CE1E498D5A6053A39AD5D91975EC27188A9360BEFFCCF4B4ACFDF052E5AA3D6A87DA16E31C2805EA5CC803191D981092F8D8EC014595971A394998A2B0D4061ED7BE0047B2FD2A24AD8725AD3353D3A49D3F0104160DD5EBA9101F27B6DAD3DF9555A8C424C83DB37EAA7EB31CE5869E739"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/rsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/rng.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      const vector<uint8_t> hexM = hex_decode(HEX_M);
      const vector<uint8_t> valE = hex_decode(VAL_E);
      const vector<uint8_t> valP = hex_decode(VAL_P);
      const vector<uint8_t> valQ = hex_decode(VAL_Q);
  
      AutoSeeded_RNG rng;
  
      BigInt e(valE);
      BigInt p(valP);
      BigInt q(valQ);
      BigInt n(p * q);
  
      Botan::RSA_PublicKey pubkey(n, e);
  
      //encrypt with pk
      Botan::PK_Encryptor_EME enc(pubkey, rng, "EME1(SHA-256)");
      std::vector<uint8_t> ct = enc.encrypt(hexM, rng);
  
      cout << "Enc: " << hex_encode(ct) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Enc: 0E2A669D5DFE2261B6459FE573B6FABAF6E7CAFA1D016FD80FBB602B986FC8AB4EF85CBEB3433F5859CA0177E6B78DF7A646A36CDCB9873DFDFEBC767B5772833621B1CB902AB9A0205C389463FE6D092CBE5888C334E5E9BB609321B4D50732C13065338E4DD244183402A0A00AACC31D3885BC5D0AE553C5DE3A8BEE3558AE239801F1E319C2EFE430B6247FEB07363734403CA8637FAC714FC9499A3A060E63B7631826A93034E2D50954307F43A33885446B1ED0EE94667D90EE3EB4A7FA7AB79A968E7F546735BA0373BF21E34C3F048D2FA782DF503F550D55E955BC0387C967B2C8356934B695270D40B2C0DB9C0EF269F62F5A94ACF4B5D85E4947F7

** Decrypt
#+HEADER: :var ENC_M = "0E2A669D5DFE2261B6459FE573B6FABAF6E7CAFA1D016FD80FBB602B986FC8AB4EF85CBEB3433F5859CA0177E6B78DF7A646A36CDCB9873DFDFEBC767B5772833621B1CB902AB9A0205C389463FE6D092CBE5888C334E5E9BB609321B4D50732C13065338E4DD244183402A0A00AACC31D3885BC5D0AE553C5DE3A8BEE3558AE239801F1E319C2EFE430B6247FEB07363734403CA8637FAC714FC9499A3A060E63B7631826A93034E2D50954307F43A33885446B1ED0EE94667D90EE3EB4A7FA7AB79A968E7F546735BA0373BF21E34C3F048D2FA782DF503F550D55E955BC0387C967B2C8356934B695270D40B2C0DB9C0EF269F62F5A94ACF4B5D85E4947F7"
#+HEADER: :var VAL_E = "010001"
#+HEADER: :var VAL_P = "E59E29CDC32B5186392D4A2339FBCBD47049D3A1BA3E2EE35361D8B0AECE2ACB7250F6B9454AF59F4346E669D07CAD1D77E80B2C7767B5324EA1C30390D928745A79AEAE50094CD337A45C68A3FAA46ACEFE842C99B7AD8A81990F6CD5A60D09B81C4BEF45A4A197F557F83C3806CC9B3B38454B6EAA65EEFDA2BF76CE585555"
#+HEADER: :var VAL_Q = "D4B922F0A78FFC21FFD9525481464CE1E498D5A6053A39AD5D91975EC27188A9360BEFFCCF4B4ACFDF052E5AA3D6A87DA16E31C2805EA5CC803191D981092F8D8EC014595971A394998A2B0D4061ED7BE0047B2FD2A24AD8725AD3353D3A49D3F0104160DD5EBA9101F27B6DAD3DF9555A8C424C83DB37EAA7EB31CE5869E739"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/rsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/rng.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      const vector<uint8_t> hexM = hex_decode(ENC_M);
      const vector<uint8_t> valE = hex_decode(VAL_E);
      const vector<uint8_t> valP = hex_decode(VAL_P);
      const vector<uint8_t> valQ = hex_decode(VAL_Q);
  
      AutoSeeded_RNG rng;
  
      BigInt e(valE);
      BigInt p(valP);
      BigInt q(valQ);
  
      Botan::RSA_PrivateKey prikey(p, q, e);
      BigInt prid = prikey.get_d();
  
      //encrypt with pk
      Botan::PK_Decryptor_EME dec(prikey, rng, "EME1(SHA-256)");
      secure_vector<uint8_t> pt = dec.decrypt(hexM);
  
      cout << "Dec: " << hex_encode(pt) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Dec: 000102030405060708090A0B0C0D0E0F

** Sign
#+HEADER: :var HEX_M = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var VAL_E = "010001"
#+HEADER: :var VAL_P = "E59E29CDC32B5186392D4A2339FBCBD47049D3A1BA3E2EE35361D8B0AECE2ACB7250F6B9454AF59F4346E669D07CAD1D77E80B2C7767B5324EA1C30390D928745A79AEAE50094CD337A45C68A3FAA46ACEFE842C99B7AD8A81990F6CD5A60D09B81C4BEF45A4A197F557F83C3806CC9B3B38454B6EAA65EEFDA2BF76CE585555"
#+HEADER: :var VAL_Q = "D4B922F0A78FFC21FFD9525481464CE1E498D5A6053A39AD5D91975EC27188A9360BEFFCCF4B4ACFDF052E5AA3D6A87DA16E31C2805EA5CC803191D981092F8D8EC014595971A394998A2B0D4061ED7BE0047B2FD2A24AD8725AD3353D3A49D3F0104160DD5EBA9101F27B6DAD3DF9555A8C424C83DB37EAA7EB31CE5869E739"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/rsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      const vector<uint8_t> hexM = hex_decode(HEX_M);
      const vector<uint8_t> valE = hex_decode(VAL_E);
      const vector<uint8_t> valP = hex_decode(VAL_P);
      const vector<uint8_t> valQ = hex_decode(VAL_Q);
  
      AutoSeeded_RNG rng;
  
      BigInt e(valE);
      BigInt p(valP);
      BigInt q(valQ);
  
      Botan::RSA_PrivateKey prikey(p, q, e);
  
      BigInt prid = prikey.get_d();
  
      // // sign data
      Botan::PK_Signer signer(prikey, rng, "EMSA1(SHA-256)");
      signer.update(hexM);
      std::vector<uint8_t> signature = signer.signature(rng);
      std::cout << "Signature: " << Botan::hex_encode(signature) << endl;
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature: 12EBA52F3A05A42E14C131B031A6212A0E1B69A4DF226703E431CED99527A9E09373695343646ED93F3881A4A54896B609A626A4DA2291C97B079A3A748528192E76D0EF6E18C6FE73454A12CE06095608B3521A125454768344EB16FAF2C5048C2083EA987BF5F521642576A7B7E705BF3BB71E6813D139D8401B81EC1116D9AB6371D997834F5673658B5E2A42B96E6CB3F057C912FED5D72891EC1DF1B495CDCCE58F56F60EF4AF3678F478694902C359E8F09101EF1FC0DD9E7C82DA38C1BC86C7A3BCCFE285675BEF55BBCD8244BC6C563D4A1D84674B4E5B92903B7717E7AE8656BDAB01A48A7301702598CDE92C662897E03946E2E5AE035CCD19C245

** Verify
#+HEADER: :var SIGN  = "12EBA52F3A05A42E14C131B031A6212A0E1B69A4DF226703E431CED99527A9E09373695343646ED93F3881A4A54896B609A626A4DA2291C97B079A3A748528192E76D0EF6E18C6FE73454A12CE06095608B3521A125454768344EB16FAF2C5048C2083EA987BF5F521642576A7B7E705BF3BB71E6813D139D8401B81EC1116D9AB6371D997834F5673658B5E2A42B96E6CB3F057C912FED5D72891EC1DF1B495CDCCE58F56F60EF4AF3678F478694902C359E8F09101EF1FC0DD9E7C82DA38C1BC86C7A3BCCFE285675BEF55BBCD8244BC6C563D4A1D84674B4E5B92903B7717E7AE8656BDAB01A48A7301702598CDE92C662897E03946E2E5AE035CCD19C245"
#+HEADER: :var HEX_M = "000102030405060708090A0B0C0D0E0F"
#+HEADER: :var VAL_E = "010001"
#+HEADER: :var VAL_P = "E59E29CDC32B5186392D4A2339FBCBD47049D3A1BA3E2EE35361D8B0AECE2ACB7250F6B9454AF59F4346E669D07CAD1D77E80B2C7767B5324EA1C30390D928745A79AEAE50094CD337A45C68A3FAA46ACEFE842C99B7AD8A81990F6CD5A60D09B81C4BEF45A4A197F557F83C3806CC9B3B38454B6EAA65EEFDA2BF76CE585555"
#+HEADER: :var VAL_Q = "D4B922F0A78FFC21FFD9525481464CE1E498D5A6053A39AD5D91975EC27188A9360BEFFCCF4B4ACFDF052E5AA3D6A87DA16E31C2805EA5CC803191D981092F8D8EC014595971A394998A2B0D4061ED7BE0047B2FD2A24AD8725AD3353D3A49D3F0104160DD5EBA9101F27B6DAD3DF9555A8C424C83DB37EAA7EB31CE5869E739"
#+begin_src C++
  #include <botan/auto_rng.h>
  #include <botan/rsa.h>
  #include <botan/pubkey.h>
  #include <botan/hex.h>
  #include <botan/bigint.h>
  #include <iostream>
  
  using namespace std;
  using namespace Botan;
  
  int main()
  {
      const vector<uint8_t> signature = hex_decode(SIGN);
      const vector<uint8_t> hexM = hex_decode(HEX_M);
      const vector<uint8_t> valE = hex_decode(VAL_E);
      const vector<uint8_t> valP = hex_decode(VAL_P);
      const vector<uint8_t> valQ = hex_decode(VAL_Q);
  
      AutoSeeded_RNG rng;
  
      BigInt e(valE);
      BigInt p(valP);
      BigInt q(valQ);
      BigInt n(p * q);
  
      Botan::RSA_PublicKey pubkey(n, e);
  
      // // verify signature
      Botan::PK_Verifier verifier(pubkey, "EMSA1(SHA-256)");
      verifier.update(hexM);
      std::cout << "Signature " << (verifier.check_signature(signature)? "Valid" : "Invalid");
  
      return 0;
  }
#+end_src

#+RESULTS:
: Signature Valid
